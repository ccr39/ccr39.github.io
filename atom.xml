<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCR39のLazyNest</title>
  
  <subtitle>QAQ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ccr39.github.io/"/>
  <updated>2025-02-06T06:37:16.264Z</updated>
  <id>http://ccr39.github.io/</id>
  
  <author>
    <name>ccr39</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学校机房无法访问互联网之联网教程</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/LW/"/>
    <id>http://ccr39.github.io/资源/LW/</id>
    <published>2025-02-06T08:06:45.000Z</published>
    <updated>2025-02-06T06:37:16.264Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center">机房联网教程</h1><h2 align="right">——By ccr39</h2><blockquote><p>由于学校机房可能会阻止机房电脑访问互联网，此篇教程旨在利用局域网代理来使机房电脑连接到互联网。</p><p>请现在校园网下可以访问互联网的设备（如教室多媒体）下使用本教程搭建代理服务，再在机房计算机内配置代理。</p><p><strong>请事先查询电脑操作系统是64位还是32位</strong>：右击此电脑-&gt;点击属性-&gt;系统类型</p></blockquote><h2 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h2><p>使用局域网代理的方式，通过设置内网服务器，并提供网络代理服务，并最终访问互联网。</p><h2 id="二、使用工具"><a href="#二、使用工具" class="headerlink" title="二、使用工具"></a>二、使用工具</h2><p><strong>Clash for Windows</strong>： <a href="https://pan.c1en.cn/s/D2XFg">32 位电脑下载</a>；<a href="https://pan.c1en.cn/s/kVxhw">64 位电脑下载</a>)；<a href="https://down.clashcn.com/soft/clashcn.com_Clash.for.Windows-0.20.39-win-CN.7z">备用1</a>；<a href="https://dl.haojichang.com/apps/clash_for_windows/">备用2</a>；<a href="https://archive.org/download/clash_for_windows_pkg">备用3</a>；</p><h2 id="三、快速开始"><a href="#三、快速开始" class="headerlink" title="三、快速开始"></a>三、快速开始</h2><h3 id="1、服务端设置代理"><a href="#1、服务端设置代理" class="headerlink" title="1、服务端设置代理"></a>1、服务端设置代理</h3><p><strong>请在多媒体上进行以下操作</strong></p><h4 id="①下载Clash-for-Windows并安装"><a href="#①下载Clash-for-Windows并安装" class="headerlink" title="①下载Clash for Windows并安装"></a>①下载Clash for Windows并安装</h4><p> <a href="https://pan.c1en.cn/s/D2XFg">32 位电脑下载</a>；<a href="https://pan.c1en.cn/s/kVxhw">64 位电脑下载</a></p><p>因为多媒体每次重启会重置C盘，因此建议将默认下载地址改为D盘，并且记住下载目录。</p><p>若出现<strong>下载慢、安装失败、版本不对</strong>请使用备用下载链接。</p><h3 id="②查询本机内网ip与端口（如果界面为英文，请按照对应位置进行操作）"><a href="#②查询本机内网ip与端口（如果界面为英文，请按照对应位置进行操作）" class="headerlink" title="②查询本机内网ip与端口（如果界面为英文，请按照对应位置进行操作）"></a>②查询本机内网ip与端口（如果界面为英文，请按照对应位置进行操作）</h3><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/new_dyn/dfb88fea26fee3fa9de42359b415ef071865926893.png" alt="image-20250206132817865"></p><p>先<strong>记录下端口号</strong>，如果为空，可以点击并更改，建议改为方便记忆的端口号。</p><p>再点击“允许互联网连接”后面的图标，记录<strong>地址后面的ip地址</strong></p><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/new_dyn/6aa7b6eea432d29cd626e6b4a7adcba11865926893.png" alt="image-20250206133206226"></p><h4 id="③开启”允许局域网连接”"><a href="#③开启”允许局域网连接”" class="headerlink" title="③开启”允许局域网连接”"></a>③开启”允许局域网连接”</h4><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/new_dyn/888aabd9e3c13bd2a447c22737c0f5151865926893.png" alt="image-20250206133333159"></p><p><strong>确保这一项打开即可，其他不用管，以上即为全部操作，请保持此电脑开启</strong></p><h3 id="2、代理端设置"><a href="#2、代理端设置" class="headerlink" title="2、代理端设置"></a>2、代理端设置</h3><p><strong>请在机房内以下操作</strong></p><h4 id="①打开控制面板"><a href="#①打开控制面板" class="headerlink" title="①打开控制面板"></a>①打开控制面板</h4><p><img src="https://exp-picture.cdn.bcebos.com/4a6d48ee7b7f860edcbcd34177f5ee0d3bcebe62.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80"></p><h4 id="②点击“网络和-Internet”。进入网络设置。"><a href="#②点击“网络和-Internet”。进入网络设置。" class="headerlink" title="②点击“网络和 Internet”。进入网络设置。"></a>②点击“网络和 Internet”。进入网络设置。</h4><p><img src="https://exp-picture.cdn.bcebos.com/732a12e265e7340fceb1229635b9763e20c2b462.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80"></p><h4 id="③点击“网络和共享中心”，点击左下角的“Internet选项”进入Internet属性设置。"><a href="#③点击“网络和共享中心”，点击左下角的“Internet选项”进入Internet属性设置。" class="headerlink" title="③点击“网络和共享中心”，点击左下角的“Internet选项”进入Internet属性设置。"></a>③点击“网络和共享中心”，点击左下角的“Internet选项”进入Internet属性设置。</h4><p><img src="https://exp-picture.cdn.bcebos.com/423041db3620b93a19401670ad0f8835dc8a8a62.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80"></p><h4 id="④选择“连接”，然后进入“高级设置”。"><a href="#④选择“连接”，然后进入“高级设置”。" class="headerlink" title="④选择“连接”，然后进入“高级设置”。"></a>④选择“连接”，然后进入“高级设置”。</h4><p><img src="https://exp-picture.cdn.bcebos.com/d400248ca608a50f7535663910cec7f88b77ff62.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80"></p><h4 id="⑤勾选”为LAN使用代理服务器”，填写IP地址和端口号信息。"><a href="#⑤勾选”为LAN使用代理服务器”，填写IP地址和端口号信息。" class="headerlink" title="⑤勾选”为LAN使用代理服务器”，填写IP地址和端口号信息。"></a>⑤勾选”为LAN使用代理服务器”，填写IP地址和端口号信息。</h4><p><img src="https://exp-picture.cdn.bcebos.com/2e66f9ef28066b017f1405f53df39187021cf362.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_auto/quality,q_80"></p><p>这里把之前记录的地址和端口填入，点击确定即可完成。</p><h3 id="3、完成"><a href="#3、完成" class="headerlink" title="3、完成"></a>3、完成</h3><p>祝大家爽玩</p><h3 id="4、翻墙操作（不想翻墙可以不看，看不懂可以不看）"><a href="#4、翻墙操作（不想翻墙可以不看，看不懂可以不看）" class="headerlink" title="4、翻墙操作（不想翻墙可以不看，看不懂可以不看）"></a>4、翻墙操作（不想翻墙可以不看，看不懂可以不看）</h3><p>由于在机房电脑设置了局域网代理，因此不能再次设置互联网代理，想要使用梯子，<strong>必须在多媒体的Clas上配置</strong>。</p><p>在“配置”里输入订阅连接点击下载即可，并在“常规”中启动系统代理。</p><p><strong>这样就可以为所有使用此服务器的客户端都使用VPN进行代理</strong></p><p>免费放一个订阅链接（不嫌麻烦顺手导入就可以）：</p><pre><code>https://36ba8c72.ghelper.me/subs/clash/53b94da436ba8c72acbd137a45cd6003</code></pre><p>免费机场：</p><p><a href="https://ikuuu.one/auth/register?code=74mH">登录 — iKuuu VPN</a></p><p>付费机场：</p><p><a href="http://106.75.143.245:3390/api/v1/client/subscribe?token=f56a2993d9e27fe65a51986cbe3fcc72">XSUS</a></p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      由于学校机房可能会阻止机房电脑访问互联网，此篇教程旨在利用局域网代理来使机房电脑连接到互联网。
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="技术" scheme="http://ccr39.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>从零开始编写一个浏览器笔记脚本</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/nicoNote/"/>
    <id>http://ccr39.github.io/技术/nicoNote/</id>
    <published>2024-12-14T13:34:20.000Z</published>
    <updated>2024-12-19T08:00:01.069Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ccr39/NicoNote/">ccr39&#x2F;NicoNote: 从零开始编写的浏览器笔记脚本</a></p><blockquote><p>故事的开始：</p><p>在浏览器上学习时时常要记笔记。</p><p>在预览网络上已有的各类插件后本人发现，这类插件往往已经长时间失去维护，或需要付费使用。</p><p>为什么不自己制作一个有类似功能的脚本呢？</p><p>在几乎没有任何理论知识的前提下本人决定实施这个构想。</p></blockquote><h2 id="一、开始前的准备"><a href="#一、开始前的准备" class="headerlink" title="一、开始前的准备"></a>一、开始前的准备</h2><h3 id="希望实现的功能"><a href="#希望实现的功能" class="headerlink" title="希望实现的功能"></a>希望实现的功能</h3><p>基本功能：</p><ul><li><input checked="" disabled="" type="checkbox"> <del>能够在网页上编写笔记，并保存在本地。可以在打开网页后显示对应笔记。</del></li><li><input checked="" disabled="" type="checkbox"> <del>能够使用 Markdown 语法并实现实时渲染 $\LaTeX$ 。</del></li><li><input checked="" disabled="" type="checkbox"> <del>能够导出与导入 Markdown 笔记。</del></li><li><input checked="" disabled="" type="checkbox"> <del>能够调整笔记框的大小。</del></li></ul><p>进阶功能：</p><ul><li><input disabled="" type="checkbox"> 美化笔记框背景。</li><li><input disabled="" type="checkbox"> 可以根据网页中的某条内容链接到笔记的某一部分。</li><li><input disabled="" type="checkbox"> 可以根据视频的进度链接到笔记。</li><li><input disabled="" type="checkbox"> 自定义笔记框。</li><li><input disabled="" type="checkbox"> （待思考）</li></ul><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>1、使用 <strong>Tampermonkey</strong> 编写基本主体脚本。这需要学习一部分网页前端知识。</p><p>2、使用开源的纯前端 Markdown 文字编辑器。</p><p>3、利用 <strong>Git</strong> 进行版本控制与脚本的发布。</p><h2 id="二、让我们开始吧"><a href="#二、让我们开始吧" class="headerlink" title="二、让我们开始吧"></a>二、让我们开始吧</h2><p>尝试了解 <strong>Tampermonkey</strong>，发现官方文档没有进行汉化，因此翻阅了中文的<a href="https://learn.scriptcat.org/%E7%AE%80%E4%BB%8B/">油猴开发指南</a>。</p><h3 id="1、对头部元数据的理解"><a href="#1、对头部元数据的理解" class="headerlink" title="1、对头部元数据的理解"></a>1、对头部元数据的理解</h3><table><thead><tr><th>元数据</th><th>值</th></tr></thead><tbody><tr><td><code>@name( :zh-CN :zh-TW :en )</code></td><td>脚本的名字(简中，繁中，英文)。</td></tr><tr><td><code>@namespace</code></td><td>一般为一个 URL 或自定义的内容，用于脚本管理器在<code>@name</code>相同的情况下识别唯一的脚本</td></tr><tr><td><code>@version</code></td><td>脚本的版本。</td></tr><tr><td><code>@author </code></td><td>脚本作者。</td></tr><tr><td><code>@description( :zh-CN :zh-YW :en )</code></td><td>脚本的描述(简中，繁中，英文)。</td></tr><tr><td><code>@include</code></td><td>脚本应该运行的页面， 可以使用<strong>通配符</strong>， 允许多个标签。</td></tr><tr><td><code>@match</code></td><td>与@include相似，区别是不可以用通配符，更精确因此更为常用，允许多个标签。</td></tr><tr><td><code>@exclude</code></td><td>排除URL，即使它们包含在@include或@match中 ，允许多个标签。</td></tr><tr><td><code>@icon  @iconURL</code> <code>@defaulticon</code></td><td>脚本的图标的 URL，会在脚本管理列表上显示。</td></tr><tr><td><code>@icon64</code> <code>@icon64URL</code></td><td>64*64 的图标文件的 URL ，可能会在选项中缩放。</td></tr><tr><td><code>@updateURL</code></td><td>更新脚本的地址，该URL应该指向一个脚本文件，只需要定期更新该文件即可实现对脚本的更新。注意：只有存在@version标签才会去更新。</td></tr><tr><td><code>@downloadURL</code></td><td>定义脚本的下载地址（一般指的是手动安装脚本时的文件）通常和 <code>@updateURL</code> 指向同一文件较常见。</td></tr><tr><td><code>@license</code></td><td>用于声明脚本的<strong>许可证类型</strong>。许可证定义了其他人如何使用、修改和分发你的脚本。</td></tr><tr><td><code>@grant</code></td><td>声明脚本会用到的<strong>特殊权限或功能</strong>。它决定了脚本是否可以使用某些特定的 API，或者是否可以访问用户脚本管理器提供的功能。可以存在多条</td></tr><tr><td><code>@require</code></td><td>指向一个脚本文件，会在本脚本运行前加载并执行</td></tr><tr><td><code>@run-at</code></td><td>定义脚本被注入的时间，与其他脚本处理相反，<code>@run-at</code> 定义了脚本要运行的第一可能时间。这意味着，使用<code>@require</code>标记的脚本可能会在文档已加载后执行，因为获取所需脚本花费了很长时间。</td></tr><tr><td><code>@supportURL</code></td><td>插件个人支持的地址，用于提交 issue 。</td></tr><tr><td><code>@homepage</code> <code>@homepageURL</code> <code>@website</code>  <code>@source</code></td><td>在“选项”页上用于从脚本名链接到给定页的作者主页。请注意，如果@namespace标记以“http:&#x2F;&#x2F;”开头，则其内容也将用于此操作。</td></tr><tr><td><code>@connect</code></td><td>用于声明可以与那些外部的域名进行跨域通信，未声明的域名在脚本中将被禁止访问，允许多个标签。可以使用<code>@connect *</code>允许所有域名（不推荐，可能带来安全风险）。</td></tr></tbody></table><p><strong>部分元数据的常用值</strong></p><p>①关于<code>@license</code>常见的许可证类型：</p><table><thead><tr><th><strong>许可证</strong></th><th><strong>作用&#x2F;特点</strong></th></tr></thead><tbody><tr><td><strong>MIT</strong></td><td>允许几乎任何使用，包括修改、分发和商业用途，只需保留原作者声明。</td></tr><tr><td><strong>GNU GPL-3.0</strong></td><td>允许修改和分发，但要求开源修改后的版本，适合需要保持自由传播的软件。</td></tr><tr><td><strong>Apache-2.0</strong></td><td>类似于 MIT，但要求保留通知文件，并保护专利权。</td></tr><tr><td><strong>CC-BY-4.0</strong></td><td>允许分享和修改，只需署名原作者，常用于非软件内容。</td></tr><tr><td><strong>Unlicense</strong></td><td>放弃所有版权，允许任何用途。</td></tr><tr><td><strong>WTFPL</strong></td><td><code>Do What The Fuck You Want To Public License</code>中文译：你他妈的想干嘛就干嘛公共许可证。是一种不太常用的、极度放任的自由软件许可证。它的条款基本等同于贡献到公有领域。</td></tr><tr><td><strong>Custom</strong></td><td>自定义声明，允许作者明确指定特殊的版权声明，例如：<code>仅供个人使用，禁止修改传播</code>。</td></tr></tbody></table><p>②<code>@grant</code> 的常用值</p><table><thead><tr><th><strong>@grant 值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>none</code></td><td>不授予任何特殊权限，脚本与页面共享相同的全局作用域。</td></tr><tr><td><code>GM_addStyle</code></td><td>向页面动态添加 CSS 样式。</td></tr><tr><td><code>GM_getValue</code></td><td>从脚本的本地存储中获取数据。</td></tr><tr><td><code>GM_setValue</code></td><td>将数据存储到脚本的本地存储中。</td></tr><tr><td><code>GM_deleteValue</code></td><td>删除脚本本地存储中的数据。</td></tr><tr><td><code>GM_listValues</code></td><td>获取所有存储值的键名列表。</td></tr><tr><td><code>GM_xmlhttpRequest</code></td><td>发起跨域的 HTTP 请求（比原生的 <code>XMLHttpRequest</code> 更强大）。</td></tr><tr><td><code>GM_download</code></td><td>下载文件到本地。</td></tr><tr><td><code>GM_notification</code></td><td>在桌面弹出通知。</td></tr><tr><td><code>GM_openInTab</code></td><td>在新标签页中打开一个链接。</td></tr><tr><td><code>GM_registerMenuCommand</code></td><td>向用户脚本菜单添加自定义选项。</td></tr><tr><td><code>GM_unregisterMenuCommand</code></td><td>删除自定义的菜单选项。</td></tr><tr><td><code>GM_setClipboard</code></td><td>将内容复制到系统剪贴板。</td></tr><tr><td><code>GM_info</code></td><td>提供有关用户脚本的信息（只读）。</td></tr></tbody></table><p>③<code>@run-at</code>的常用值</p><table><thead><tr><th><strong>@run-at 值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>document-start</code></td><td>脚本会被尽可能快地注入</td></tr><tr><td><code>document-body</code></td><td>当body元素存在是被注入</td></tr><tr><td><code>document-end</code></td><td>当 DOMContentLoaded 事件被触发时或者之后注入</td></tr><tr><td><code>document-idle</code></td><td>当 DOMContentLoaded 事件被触发后被注入 如果没有@run-at标签也是在此时注入</td></tr></tbody></table><h3 id="2、目前产生的问题（ChatGPT-解答）"><a href="#2、目前产生的问题（ChatGPT-解答）" class="headerlink" title="2、目前产生的问题（ChatGPT 解答）"></a>2、目前产生的问题（ChatGPT 解答）</h3><h5 id="Q-1：-downloadURL和-updateURL的区别"><a href="#Q-1：-downloadURL和-updateURL的区别" class="headerlink" title="Q.1：@downloadURL和@updateURL的区别"></a><strong>Q.1：@downloadURL和@updateURL的区别</strong></h5><blockquote><p>在编写油猴（Tampermonkey 或 Greasemonkey）脚本时，<code>@include</code> 和 <code>@match</code> 是用来定义脚本作用范围的元数据注释。它们的作用类似，但有一些关键区别：</p><p><strong>@include</strong></p><ul><li><p><strong>用途</strong>：匹配指定的 URL 模式，让脚本在符合模式的页面上运行。</p></li><li><p><strong>语法</strong>：支持通配符（*），简单易用。</p><ul><li><p><code>*</code>：匹配任意字符。</p></li><li><p>示例：</p><pre><code class="javascript"> // 脚本会在所有以 &quot;https://example.com/&quot; 开头的页面上运行@include https://example.com/*</code></pre></li></ul></li><li><p>匹配示例：</p><ul><li><pre><code>https://example.com/*</code></pre><p> 可以匹配：</p><ul><li><code>https://example.com/page1</code></li></ul></li><li><p><code>https://example.com/page2</code></p></li><li><p>通配符 *也可以放在中间或末尾，如：</p><ul><li><code>https://*.example.com/*</code> 匹配所有子域名。</li></ul></li></ul></li></ul><p><strong>@match</strong></p><ul><li><p><strong>用途</strong>：更严格地匹配 URL 模式，符合 URL 模式规范。</p></li><li><p><strong>语法</strong>：不支持简单的 * 通配符定义所有，而是更精确的匹配规则。</p><ul><li><p>但可以使用通配符 <code>*</code> 匹配子域名或协议。</p></li><li><p>示例：</p><pre><code> javascript复制代码// 脚本会在 https://example.com 的所有页面运行@match https://example.com/*</code></pre></li></ul><pre><code></code></pre></li><li><p>匹配示例：</p><ul><li><pre><code>https://*.example.com/*</code></pre><p> 可以匹配：</p><ul><li><code>https://sub.example.com/page</code></li></ul></li><li><p><code>https://another.example.com/page</code></p></li></ul></li><li><p>但不会匹配：</p><ul><li><code>http://example.com</code>（因为协议不同）。</li></ul></li></ul><p><strong>关键区别</strong></p><table><thead><tr><th>特性</th><th><code>@include</code></th><th><code>@match</code></th></tr></thead><tbody><tr><td><strong>灵活性</strong></td><td>支持简单通配符，较宽松</td><td>严格匹配 URL，符合标准规范</td></tr><tr><td><strong>安全性</strong></td><td>容易出现误匹配</td><td>更严格，减少误匹配的风险</td></tr><tr><td><strong>协议要求</strong></td><td>可以省略协议</td><td>必须指定协议（<code>http://</code> 或 <code>https://</code>）</td></tr><tr><td><strong>兼容性</strong></td><td>旧版脚本可能使用更多</td><td>推荐使用，符合现代浏览器扩展规范</td></tr></tbody></table><p><strong>使用建议</strong></p><ol><li>如果需要快速定义作用域，且 URL 规则较简单，可以使用 <code>@include</code>。</li><li>如果需要更安全、更准确的匹配，建议使用 <code>@match</code>，特别是在现代浏览器扩展环境下。</li></ol><blockquote><p>现代浏览器和 Tampermonkey 都更推荐使用 <code>@match</code>，因为它的匹配规则符合浏览器扩展的标准。</p></blockquote><p><strong>个人总结</strong></p><p>两者用来将脚本应用到所有的页面，应分别如下写：</p><p><code>@match        *://*/*</code></p><p><code>@include   *</code></p></blockquote><h5 id="Q-2：什么是-DOMContentLoaded-事件？"><a href="#Q-2：什么是-DOMContentLoaded-事件？" class="headerlink" title="Q.2：什么是 DOMContentLoaded 事件？"></a>Q.2：什么是 DOMContentLoaded 事件？</h5><blockquote><p><code>DOMContentLoaded</code> 是一个常见的 JavaScript 事件，用于监听 HTML 文档的加载状态。当浏览器解析完所有的 HTML 并构建完成 DOM 树时，就会触发 <code>DOMContentLoaded</code> 事件，而无需等待其他资源（如图片、样式表和脚本文件）的加载完成。</p><p><strong>特点</strong></p><ol><li><strong>触发时机</strong>：当 HTML 文档被完全加载和解析完成时（即 DOM 树构建完成）。</li><li><strong>不等待其他资源</strong>：与 <code>window.onload</code> 不同，<code>DOMContentLoaded</code> 不需要等待图片、样式表、iframe 等资源加载完成后才触发。</li><li><strong>适用于操作 DOM</strong>：在该事件触发时，DOM 已经可用，因此适合初始化页面内容或操作 DOM 元素。</li></ol><p><strong>用法</strong></p><p>监听 <code>DOMContentLoaded</code> 的方法有以下几种：</p><p><strong>1. 使用 <code>addEventListener</code></strong></p><pre><code class="javascript">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;    console.log(&quot;DOM 已完全加载并解析&quot;);   // 可以安全地操作 DOM 元素    document.body.style.backgroundColor = &quot;lightblue&quot;;&#125;);</code></pre><p><strong>2. 使用旧的 <code>onreadystatechange</code></strong></p><p>早期浏览器中，可以通过 <code>readyState</code> 属性判断文档是否加载完成：</p><pre><code class="javascript">document.onreadystatechange = function() &#123;    if (document.readyState === &quot;interactive&quot;) &#123;       console.log(&quot;DOM 已完全加载并解析&quot;);    &#125;&#125;;</code></pre><p><strong>3. 直接在脚本末尾执行</strong></p><p>如果你的脚本放在文档的底部（<code>&lt;/body&gt;</code>标签之前），可以不显式监听 <code>DOMContentLoaded</code>，因为此时 DOM 已经解析完成：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello, World!&lt;/h1&gt;    &lt;script&gt;        console.log(document.querySelector(&quot;h1&quot;).textContent); // &quot;Hello, World!&quot;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong><code>DOMContentLoaded</code> 和 <code>window.onload</code> 的区别</strong></p><table><thead><tr><th>特性</th><th><code>DOMContentLoaded</code></th><th><code>window.onload</code></th></tr></thead><tbody><tr><td><strong>触发时机</strong></td><td>DOM 树构建完成（HTML 已加载并解析）。</td><td>页面所有资源（包括图片、样式等）加载完成。</td></tr><tr><td><strong>是否等待外部资源</strong></td><td>不等待外部资源加载完成。</td><td>等待所有外部资源加载完成。</td></tr><tr><td><strong>使用场景</strong></td><td>初始化 DOM 操作或页面功能。</td><td>确保所有资源可用（如图片尺寸）。</td></tr></tbody></table><p><strong>示例：两者对比</strong></p><pre><code class="javascript">document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;    console.log(&quot;DOM 已加载完成，但图片可能还在加载中&quot;);&#125;);window.addEventListener(&quot;load&quot;, function() &#123;    console.log(&quot;页面所有资源加载完成，包括图片和样式&quot;);&#125;);</code></pre><p><strong>浏览器支持</strong></p><p><code>DOMContentLoaded</code> 是一个标准事件，现代浏览器（包括 IE9+）都完全支持。</p><p><strong>使用建议</strong></p><ul><li><strong>推荐场景</strong>：如果你的脚本只需要操作 DOM 元素（如添加事件监听器或修改内容），优先使用 <code>DOMContentLoaded</code>，因为它比 <code>window.onload</code> 更早触发。</li><li><strong>性能优化</strong>：通过监听 <code>DOMContentLoaded</code>，可以更快地响应用户交互，而无需等待所有资源加载完成。</li></ul></blockquote><h5 id="Q-3：什么是DOM树？"><a href="#Q-3：什么是DOM树？" class="headerlink" title="Q.3：什么是DOM树？"></a><strong>Q.3：什么是DOM树？</strong></h5><p><strong>DOM 树</strong>（Document Object Model Tree）是浏览器在加载和解析 HTML 文档时，根据 HTML 的层级结构生成的一种<strong>树形数据结构</strong>。它表示了文档的结构以及每个节点之间的关系，使得 JavaScript 可以通过 DOM API 操作页面内容和结构。</p><blockquote><p><strong>DOM 树的组成</strong></p><p>DOM 树由以下几种节点组成，每个节点代表 HTML 文档的一部分：</p><ol><li><strong>文档节点（Document Node）</strong>：<ul><li>表示整个 HTML 文档的根节点。</li><li>通过 JavaScript 的 <code>document</code> 对象访问。</li></ul></li><li><strong>元素节点（Element Nodes）</strong>：<ul><li>表示 HTML 的元素标签，例如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>。</li><li>元素节点可以嵌套形成层级结构。</li></ul></li><li><strong>属性节点（Attribute Nodes）</strong>：<ul><li>表示 HTML 元素的属性，例如 <code>id=&quot;example&quot;</code>。</li><li>属性是元素节点的一部分，但在 DOM 树中不是子节点，而是直接附属于对应的元素节点。</li></ul></li><li><strong>文本节点（Text Nodes）</strong>：<ul><li>表示元素或属性中的文本内容。</li><li>文本节点始终是叶节点，没有子节点。</li></ul></li><li><strong>注释节点（Comment Nodes）</strong>：<ul><li>表示 HTML 文档中的注释内容。</li></ul></li></ol><p><strong>DOM 树的结构</strong></p><p>以以下 HTML 代码为例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Example&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1 id=&quot;header&quot;&gt;Hello, World!&lt;/h1&gt;    &lt;p&gt;Welcome to DOM.&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>对应的 DOM 树结构如下：</p><pre><code class="bash">Document └── html      ├── head      │     └── title      │           └── &quot;Example&quot;      └── body            ├── h1            │     ├── Attribute: id=&quot;header&quot;            │     └── &quot;Hello, World!&quot;            └── p                  └── &quot;Welcome to DOM.&quot;</code></pre><p><strong>DOM 树的特点</strong></p><ol><li><strong>层级关系</strong>：</li></ol><ul><li>HTML 文档的嵌套结构会在 DOM 树中反映为父子关系。</li><li>每个 HTML 元素是一个节点，嵌套关系形成了树状层级。</li></ul><ol start="2"><li><strong>节点类型</strong>：<ul><li>可以通过 <code>nodeType</code> 属性查看节点类型，例如：<ul><li><code>1</code>：元素节点</li><li><code>3</code>：文本节点</li><li><code>8</code>：注释节点</li></ul></li></ul></li><li><strong>可遍历</strong>：<ul><li>DOM 树中的节点可以通过 JavaScript 遍历，例如 <code>parentNode</code>、<code>childNodes</code>、<code>nextSibling</code> 等。</li></ul></li></ol><p><strong>常见操作</strong></p><ol><li><p><strong>获取节点</strong>：</p><pre><code class="javascript"> const header = document.getElementById(&quot;header&quot;); // 获取 h1 元素const paragraphs = document.getElementsByTagName(&quot;p&quot;); // 获取所有 &lt;p&gt; 元素</code></pre></li></ol><pre><code>2. **修改节点内容**： ```javascriptconst header = document.getElementById(&quot;header&quot;); header.textContent = &quot;Hello, DOM!&quot;;</code></pre><ol start="3"><li><p><strong>添加新节点</strong>：</p><pre><code class="javascript"> const newDiv = document.createElement(&quot;div&quot;);newDiv.textContent = &quot;This is a new div.&quot;; document.body.appendChild(newDiv);</code></pre></li><li><p><strong>删除节点</strong>：</p><pre><code class="javascript"> const header = document.getElementById(&quot;header&quot;);header.remove();</code></pre></li></ol><pre><code>**DOM 树的作用**1. **页面动态交互**：通过操作 DOM 树，可以动态修改页面的结构和内容。2. **事件绑定**：JavaScript 事件处理器通过 DOM 树关联 HTML 元素。3. **样式动态调整**：通过修改 DOM 节点的样式属性实现动态效果。**总结**DOM 树是 HTML 文档在浏览器中的表示形式，它将 HTML 结构化为可以用 JavaScript 操作的对象模型。熟练掌握 DOM 树和相关操作是前端开发的基础。</code></pre></blockquote><p>2024&#x2F;12&#x2F;8</p><hr><h3 id="3、Hello-World"><a href="#3、Hello-World" class="headerlink" title="3、Hello World"></a>3、Hello World</h3><p>在头部元数据下方标注了书写代码的地方。</p><pre><code class="javascript">(function() &#123;    &#39;use strict&#39;;// Your code here...&#125;)();</code></pre><p>根据文档描述，脚本的书写应该使用<code>JavaScript</code>。</p><p>利用<code>alert()</code>弹出一个对话框，并输出 HelloWorld，并使用<code>@include *</code>将其应用到所有页面。</p><pre><code class="javascript">// ==UserScript==//@name    a_simple_test//@include *// ==/UserScript==(function() &#123;    &#39;use strict&#39;;    alert(&#39;HelloWorld&#39;)// Your code here...&#125;)();</code></pre><p>这样，在打开任意网站后，都会弹出一个 HelloWorld 的对话框。</p><h3 id="4、熟悉-JavaScript-的语法"><a href="#4、熟悉-JavaScript-的语法" class="headerlink" title="4、熟悉  JavaScript  的语法"></a>4、熟悉  JavaScript  的语法</h3><p>在<a href="https://www.runoob.com/js/js-howto.html">JavaScript 用法 | 菜鸟教程</a>中了解JS的基本用法。</p><p>在此出现的问题：</p><h5 id="Q-4：之前-HelloWorld-脚本中的alert-39-HelloWorld-39-末尾没有分号，这种写法是否合法？"><a href="#Q-4：之前-HelloWorld-脚本中的alert-39-HelloWorld-39-末尾没有分号，这种写法是否合法？" class="headerlink" title="Q.4：之前 HelloWorld 脚本中的alert(&#39;HelloWorld&#39;)末尾没有分号，这种写法是否合法？"></a><strong>Q.4：之前 HelloWorld 脚本中的<code>alert(&#39;HelloWorld&#39;)</code>末尾没有分号，这种写法是否合法？</strong></h5><blockquote><p>是合法的！在 JavaScript 中，分号（<code>;</code>）是<strong>可选的</strong>，因为 JavaScript 有一个<strong>自动分号插入（Automatic Semicolon Insertion, ASI）</strong>的机制。在大多数情况下，即使你省略了分号，JavaScript 引擎也会根据上下文自动插入。</p><p><strong>解释代码中的 <code>alert(&#39;HelloWorld&#39;)</code></strong></p><p>在以下代码中：</p><pre><code class="javascript">alert(&#39;HelloWorld&#39;)</code></pre><p>即使没有写分号，JavaScript 引擎仍然能正确解析，因为：</p><ol><li><p><code>alert(&#39;HelloWorld&#39;)</code> 是一个独立的语句。</p></li><li><p>ASI 机制会在行末自动插入分号，等效于：</p><pre><code class="javascript"> alert(&#39;HelloWorld&#39;);</code></pre></li></ol><p>因此，这种省略分号的写法是合法的。</p><p><strong>什么时候分号是必要的？</strong></p><p>尽管 ASI 机制可以避免大部分语法错误，但在某些特定情况下，<strong>省略分号可能导致意外行为</strong>。例如：</p><p>情况 1：行首是 <code>[</code> 或 <code>(</code> 的表达式</p><pre><code class="javascript">let a = 5[1, 2, 3].forEach(x =&gt; console.log(x))</code></pre><p>在这种情况下，JavaScript 会将 <code>[1, 2, 3]</code> 视为数组访问器，而不是独立的数组字面量。</p><p>解决方法：</p><pre><code class="javascript">let a = 5;[1, 2, 3].forEach(x =&gt; console.log(x));</code></pre><p>情况 2：返回值与表达式在不同行</p><pre><code class="javascript">function test() &#123;    return   &#123;        value: 42    &#125;&#125;console.log(test()) // undefined</code></pre><p>在这种情况下，<code>return</code> 语句后自动插入了分号，因此实际返回的是 <code>undefined</code>。</p><p>解决方法：</p><pre><code class="javascript">function test() &#123;    return &#123;       value: 42    &#125;;&#125;</code></pre><p><strong>建议</strong></p><ol><li><strong>始终使用分号</strong>：虽然 JavaScript 的 ASI 机制可以省略分号，但为了代码的可读性和避免潜在的错误，建议显式添加分号。</li><li><strong>遵循团队规范</strong>：如果项目使用了某种代码风格（如 Airbnb 或 Standard），遵循其规范（例如 Standard JS 就不使用分号）。</li><li><strong>工具辅助</strong>：使用代码检查工具（如 ESLint）和格式化工具（如 Prettier）来统一代码风格。</li></ol><p><strong>结论</strong></p><p>在你的脚本中，省略 <code>alert(&#39;HelloWorld&#39;)</code> 的分号是合法的，且能正确运行。不过，养成显式添加分号的习惯会更安全、更规范。</p></blockquote><h3 id="5、（番外）为插件创作一个图标"><a href="#5、（番外）为插件创作一个图标" class="headerlink" title="5、（番外）为插件创作一个图标"></a>5、（番外）为插件创作一个图标</h3><p>使用 ChatGPT 绘制一个笔记本的图标，将其转换为64*64大小。</p><p>使用 <a href="https://www.jyshare.com/more/svgeditor/">SVG 在线编辑器 | 菜鸟工具</a> 将其转化为矢量图形，并使其可以用代码表示出来。</p><p>发现 ChatGPT 绘制的图形不是纯色图形，会导致代码过长，故放弃使用 ChatGPT 绘制的图形，转而使用网络上公开的资源，使用 SVG 工具将其稍加修改。</p><p>接下来，将其转换为可以直接在<code>@icon</code>后使用的格式，即 <strong>Data URI</strong> 格式。使用在线工具<a href="https://uutool.cn/svg2datauri/">在线SVG转DataURL - UU在线工具</a>自动转化。</p><h3 id="6、创建一个唤出笔记本的标识"><a href="#6、创建一个唤出笔记本的标识" class="headerlink" title="6、创建一个唤出笔记本的标识"></a>6、创建一个唤出笔记本的标识</h3><p>我们需要一个拥有以下功能的标识：</p><ul><li>在浏览器页面的边框处，并始终位于页面最上方。</li><li>点击后会唤出笔记本。</li><li>拥有一些简单的动画效果。</li><li>随页面滚动时不改变标识的位置。</li></ul><p>首先要知道如何使用 JavaScript 创建并插入 HTML 元素。</p><p>查阅了<a href="https://www.cainiaojc.com/jsref/elem_insertadjacenthtml.html">HTML DOM insertAdjacentHTML() 方法 - 菜鸟教程</a>，<a href="https://www.runoob.com/jsref/met-document-queryselector.html">HTML DOM querySelector() 方法 | 菜鸟教程</a>。</p><pre><code class="JS">document.querySelector(&quot;body&quot;).insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;div&gt;&lt;p&gt;Hello world&lt;/p&gt;&lt;/div&gt;&quot;);//表示在&lt;body&gt;元素后插入&lt;div&gt;元素。先用querySelector()获取&lt;body&gt;元素的document，再用insertAdjacentHTML(,)插入元素。</code></pre><p>现在我们要将这个元素置于我们希望它存在的位置，为此，我们需要了解如何利用脚本改变元素的 CSS 样式，以及如何书写 CSS。</p><p>设置位置查阅的资料：<a href="https://www.runoob.com/cssref/pr-class-position.html">CSS position 属性 | 菜鸟教程</a>、<a href="https://www.runoob.com/cssref/pr-pos-bottom.html">CSS bottom 属性 | 菜鸟教程</a>、<a href="https://jingyan.baidu.com/article/f3ad7d0fa974c749c3345bff.html#">使用css，如何把div设置为圆形-百度经验</a>、<a href="https://www.runoob.com/cssref/pr-border.html">CSS border 属性 | 菜鸟教程</a></p><pre><code class="JS">    document.querySelector(&quot;body&quot;).insertAdjacentHTML(&quot;afterbegin&quot;,&#39;&lt;div id=&quot;nicoBt&quot;&gt;&lt;p&gt;helloworld&lt;/&gt;&lt;/div&gt;&#39;);    //表示在&lt;body&gt;元素后插入&lt;div&gt;元素    var nicoButton = document.getElementById(&quot;nicoBt&quot;);    //var 表示定义变量，根据getElementById()利用id找到&lt;div&gt;元素    var nicoButtonStyle = &quot;\    position: fixed;\    right: 1%;\    bottom:80%;\    width: 44px;\    height: 44px;\    border: 2px solid #D3D3D3;\    border-radius: 50%;\    background: rgb(0, 127, 255);\    z-index: 2147483647;\    &quot;;    //第一句表示依照浏览器边框定位，right与bottom定义位置，width与height定义长宽，border用于定义边框，border-radius用于实现圆形效果,z-index定义了元素的图层高度，设置一个很大的数字可以保证其置于其他图像上方。    //定义&lt;div&gt;元素的CSS样式，输入字符串时进行换行操作,在每行末尾加上\    //末尾的;可加可不加    nicoButton.setAttribute(&quot;style&quot;,nicoButtonStyle);    //setAttribute(,)可以改变元素属性，用来改变nicoButton的CSS样式</code></pre><p>现在我们把这个<div>元素改写为一个按钮，把图标插入进去。</p><pre><code class="JS">var htmlNicoButton = &#39;\&lt;div id=&quot;nicoBt&quot;&gt;\        &lt;img src=&quot;图标URL&quot;&gt;\&lt;/div&gt;\&#39;;document.querySelector(&quot;body&quot;).insertAdjacentHTML(&quot;afterbegin&quot;,htmlNicoButton);//以下略</code></pre><p>2024&#x2F;12&#x2F;9</p><hr><pre><code class="CSS">    position: absolute;/*使用相对位置*/    top: 50%;/*竖直方向上一半*/    left: 50%;/*水平方向上一半*/    transform: translate(-50%, -50%);/*x,y方向上均往回移动自身的一般*/</code></pre><p>使用上面的方法把图像居中，参考：<a href="https://www.runoob.com/cssref/css3-pr-transform.html">CSS3 transform 属性 | 菜鸟教程</a></p><p>发现存在<code>&lt;iframe&gt;</code>时会添加很多的标识，希望只在主页面添加，加上判断：</p><pre><code class="JS">    if (window.self === window.top) &#123;        document.querySelector(&quot;body&quot;).insertAdjacentHTML(&quot;afterend&quot;,htmlNicoButton);    &#125;</code></pre><p>参考了<a href="https://www.runoob.com/js/js-comparisons.html">JavaScript 比较和逻辑运算符 | 菜鸟教程</a>、<a href="https://www.runoob.com/jsref/prop-win-self.html">Window self 属性 | 菜鸟教程</a></p><p>下面我们要让鼠标悬停在标识上方时有一定的反馈效果，这里利用了<code>addEventListener()</code>设置两个效果，参考了<a href="https://www.runoob.com/jsref/met-document-addeventlistener.html">HTML DOM addEventListener() 方法 | 菜鸟教程</a>。</p><pre><code class="js">    nicoButton.addEventListener(&quot;mouseover&quot;, function () &#123; //光标移动到图标上，执行函数        nicoButton.style.width = &quot;55px&quot;;        nicoButton.style.height = &quot;55px&quot;;        //大小改变        nicoButton.style.cursor = &quot;pointer&quot;;        //鼠标光标从箭头改编为小手    &#125;);    nicoButton.addEventListener(&quot;mouseout&quot;, function () &#123; //光标移开        nicoButton.style.width = &quot;48px&quot;;        nicoButton.style.height = &quot;48px&quot;;        nicoButton.style.cursor = &quot;&quot;;        //变回    &#125;);</code></pre><h3 id="7、创建一个容器"><a href="#7、创建一个容器" class="headerlink" title="7、创建一个容器"></a>7、创建一个容器</h3><p>创建一个<div>作为我们的笔记本的容器：</p><pre><code class="js">    var nicoNoteDiv = document.createElement(&quot;div&quot;);//这里用document.creatElement()创建元素。ps.比最开始进步了    nicoNoteDiv.setAttribute(&quot;id&quot;,&quot;nicoNoteDiv&quot;);</code></pre><p>用点击事件呼出编辑框，并让图标不透明度降低（参考<a href="https://blog.csdn.net/qq_43205326/article/details/110207160">css中让元素消失的方法_transition visibility 无效-CSDN博客</a>）：</p><pre><code class="js">    nicoButton.addEventListener(&quot;click&quot;, function () &#123;     document.querySelector(&quot;html&quot;).appendChild(nicoNoteDiv);//用点击事件呼出编辑框,添加在 nicoBt 后面     nicoButton.style.opacity=&quot;0.3&quot;; //图标不透明度降低    &#125;);//这里用 elementA.appendChild(elemenetB)：表明在A内最后添加B元素</code></pre><p>下面我们来设计这个<code>nicoNoteDiv</code>除了最基本的长宽位置之外，我们希望它可以允许自己通过拖拽调节大小和位置（似乎略有些麻烦）。</p><p>2024&#x2F;12&#x2F;10</p><hr><p>2024&#x2F;12&#x2F;11 去医院了，还被坑了，详情请见：<a href="https://zhuanlan.zhihu.com/p/12090143389">只身陷入心理治疗骗局！！深扒“SCIO全科生物反馈测疗仪”与“心理AI智能检测”底裤。 - 知乎</a></p><hr><h4 id="①拖拽调节位置"><a href="#①拖拽调节位置" class="headerlink" title="①拖拽调节位置"></a>①拖拽调节位置</h4><p>为了使其可以调节自身位置和大小，我们应该从两方考虑：</p><ol><li>CSS 角度，在鼠标靠近<div>边缘时，光标应该发生变化。</li><li>JS 角度，根据鼠标光标的坐标改变<div>的大小。</li></ol><p>为了实现上述操作，我们考虑把存放笔记本主体的<div>和调整大小的<div>分开，外层仅仅实现拖拽功能，内层为主体。</p><h5 id="Q-5-在查询资料时发现的-gt-是什么意思"><a href="#Q-5-在查询资料时发现的-gt-是什么意思" class="headerlink" title="Q.5:在查询资料时发现的() =&gt; {}是什么意思?"></a><strong>Q.5:在查询资料时发现的<code>() =&gt; &#123;&#125;</code>是什么意思?</strong></h5><blockquote><p><code>(e) =&gt; &#123;&#125;</code> 是 JavaScript 中的箭头函数语法，是定义函数的一种简洁方式。它可以用来代替传统的 <code>function</code> 声明。</p><p><strong>语法</strong></p><pre><code>(param1, param2, ...) =&gt; &#123; // 函数体 &#125;</code></pre><p><strong>分解理解 <code>(e) =&gt; &#123;&#125;</code></strong></p><ol><li><strong>箭头函数</strong>：<ul><li><code>=&gt;</code> 是箭头函数的核心，表示这是一个函数。</li></ul></li><li>**参数 <code>(e)</code>**：</li></ol><ul><li><code>e</code> 是箭头函数的参数。它通常代表事件对象，尤其是在事件处理程序中，比如 <code>addEventListener</code>。</li></ul><ol start="3"><li>**函数体 <code>&#123;&#125;</code>**：</li></ol><ul><li><code>&#123;&#125;</code> 包含函数执行的代码。</li></ul><p><strong>完整例子</strong></p><p>以下是一个常见的使用场景：</p><p><strong>传统函数写法</strong></p><pre><code class="javascript">document.addEventListener(&quot;click&quot;, function(e) &#123;    console.log(&quot;鼠标点击了页面&quot;, e);&#125;);</code></pre><p><strong>箭头函数写法</strong></p><pre><code class="javascript">document.addEventListener(&quot;click&quot;, (e) =&gt; &#123;    console.log(&quot;鼠标点击了页面&quot;, e);&#125;);</code></pre><p><strong>简化规则</strong></p><ol><li><p><strong>参数简写</strong>：</p><ul><li><p>如果只有一个参数，可以省略括号 ()</p><pre><code class="JS">e =&gt; console.log(e);</code></pre></li><li><p>如果没有参数或有多个参数，则必须使用括号。</p><pre><code class="javascript"> () =&gt; console.log(&quot;无参数&quot;);(x, y) =&gt; console.log(x + y);</code></pre></li></ul><pre><code></code></pre></li><li><p><strong>函数体简写</strong>：</p><ul><li>如果函数体只有一行代码，且直接返回值，可以省略 {} 和 return</li></ul><pre><code class="javascript">x =&gt; x * x; // 返回 x 的平方</code></pre></li></ol><p><strong>优势</strong></p><ul><li><strong>简洁</strong>：语法更短，易读。</li><li><strong>自动绑定上下文</strong>：箭头函数不会创建自己的 <code>this</code>，而是继承自外层作用域。</li></ul><p><strong>例子：箭头函数绑定上下文</strong></p><pre><code class="javascript">function Example() &#123;    this.name = &quot;箭头函数示例&quot;;    document.addEventListener(&quot;click&quot;, () =&gt; &#123;       console.log(this.name); // 指向 Example 实例    &#125;);&#125;new Example();</code></pre><p><strong>对比传统函数</strong></p><table><thead><tr><th>特性</th><th>箭头函数</th><th>普通函数</th></tr></thead><tbody><tr><td>语法简洁</td><td>是</td><td>否</td></tr><tr><td><code>this</code> 指向</td><td>继承外层作用域</td><td>动态绑定，取决于调用位置</td></tr><tr><td>使用场景</td><td>回调函数、简单逻辑</td><td>需要动态绑定 <code>this</code> 的复杂场景</td></tr></tbody></table><p>箭头函数非常适合在事件处理、数组操作等回调中使用，但如果需要灵活绑定 <code>this</code>，普通函数可能更适合。</p></blockquote><p><strong>先实现较简单的拖拽：</strong></p><p>首先我们应该想办法获取鼠标的光标坐标，可以利用<code>addEventListener</code>监听<code>mousemove</code>事件，再将生成的<code>MouseEvent</code> 对象传入参数，提取<code>clientX</code> 和 <code>clientY</code>的信息。</p><p>关于这一过程的具体原理 Chat GPT 回答如下：</p><blockquote><p>在以下代码中：</p><pre><code class="javascript">document.addEventListener(&#39;mousemove&#39;, (event) =&gt; &#123; const &#123; clientX, clientY &#125; = event;console.log(`鼠标X坐标: $&#123;clientX&#125;, 鼠标Y坐标: $&#123;clientY&#125;`);//console.log（）用于把信息输出到工作台。$&#123;&#125;表示在字符串中插入函数或变量。&#125;);</code></pre><p>事件参数 <code>event</code> 的捕捉和传递机制：</p><ol><li><strong>事件监听器的注册</strong>：<ul><li><code>document.addEventListener(&#39;mousemove&#39;, callback)</code> 将事件监听器绑定到 <code>document</code> 上，用于监听 <code>mousemove</code> 事件。</li><li>当用户移动鼠标时，浏览器会触发 <code>mousemove</code> 事件。</li></ul></li><li><strong>事件对象的生成</strong>：<ul><li>浏览器在触发事件时，会生成一个 <code>Event</code> 对象。对于 <code>mousemove</code> 事件，生成的对象是一个 <code>MouseEvent</code> 实例，它继承了 <code>Event</code> 的所有属性和方法，同时还包含鼠标相关的属性，比如 <code>clientX</code> 和 <code>clientY</code>。</li></ul></li><li><strong>事件对象的传递</strong>：<ul><li>当事件触发时，浏览器会将生成的 <code>MouseEvent</code> 对象作为参数传递给监听器中定义的回调函数 <code>(event) =&gt; &#123; ... &#125;</code>。</li></ul></li><li><strong>解构赋值</strong>：<ul><li>在回调函数中，通过 <code>const &#123; clientX, clientY &#125; = event;</code> 使用了<strong>解构赋值</strong>，从 <code>event</code> 对象中提取 <code>clientX</code> 和 <code>clientY</code> 属性值，代表鼠标指针相对于视口左上角的 X 和 Y 坐标。</li></ul></li><li><strong>输出结果</strong>：<ul><li>提取到的坐标值会被插入到字符串中，并通过 <code>console.log</code> 输出到控制台。</li></ul></li></ol><p>总结： 浏览器自动生成事件对象并将其作为参数传递给事件回调函数。你只需定义回调函数的参数名称（这里是 <code>event</code>），浏览器会负责传递这个对象。</p><p>MouseEvent实例中还有那些属性？</p><p><code>MouseEvent</code> 是由浏览器生成的事件对象，专门用于表示与鼠标操作相关的事件（例如 <code>click</code>、<code>mousemove</code>、<code>mousedown</code> 等）。它继承自 <code>UIEvent</code>，并进一步继承自 <code>Event</code>。<code>MouseEvent</code> 实例包含许多有用的属性，用于描述鼠标事件的详细信息。</p><p>以下是 <code>MouseEvent</code> 的主要属性：</p><p><strong>鼠标位置信息</strong></p><ul><li>**<code>clientX</code>**：鼠标指针相对于浏览器视口（窗口）左边缘的 X 坐标。</li><li>**<code>clientY</code>**：鼠标指针相对于浏览器视口（窗口）顶部的 Y 坐标。</li><li>**<code>screenX</code>**：鼠标指针相对于屏幕左边缘的 X 坐标。</li><li>**<code>screenY</code>**：鼠标指针相对于屏幕顶部的 Y 坐标。</li><li>**<code>pageX</code>**：鼠标指针相对于整个文档左边缘的 X 坐标（包括页面滚动距离）。</li><li>**<code>pageY</code>**：鼠标指针相对于整个文档顶部的 Y 坐标（包括页面滚动距离）。</li><li>**<code>offsetX</code>**：鼠标指针相对于事件目标元素左边缘的 X 坐标。</li><li>**<code>offsetY</code>**：鼠标指针相对于事件目标元素顶部的 Y 坐标。</li></ul><p><strong>鼠标按键信息</strong></p><ul><li><code>button</code>：</li><li>触发事件的鼠标按键的代码：<ul><li><code>0</code>：主按钮（通常是左键）</li><li><code>1</code>：中间按钮（滚轮）</li><li><code>2</code>：次按钮（通常是右键）</li></ul></li><li><code>buttons</code>：<ul><li>一个按位标记的数字，表示当前按下的鼠标按钮：<ul><li><code>1</code>：左键</li><li><code>2</code>：右键</li><li><code>4</code>：中键 （可以组合，如同时按下左键和右键时值为 <code>3</code>）</li></ul></li></ul></li></ul><p><strong>键盘修饰键状态</strong></p><p>这些属性表示事件发生时是否按下了修饰键：</p><ul><li>**<code>altKey</code>**：<code>true</code> 表示 <code>Alt</code> 键被按下。</li><li>**<code>ctrlKey</code>**：<code>true</code> 表示 <code>Ctrl</code> 键被按下。</li><li>**<code>metaKey</code>**：<code>true</code> 表示 <code>Meta</code> 键被按下（Mac 上为 <code>Command</code> 键）。</li><li>**<code>shiftKey</code>**：<code>true</code> 表示 <code>Shift</code> 键被按下。</li></ul><p><strong>拖放和相关元素</strong></p><ul><li><code>relatedTarget</code>：<ul><li>对于某些事件（如 <code>mouseover</code> 和 <code>mouseout</code>），表示鼠标从哪个元素移入&#x2F;移出。</li></ul></li><li><code>target</code>：</li><li>事件的目标元素。</li><li><code>currentTarget</code>：</li><li>当前正在处理事件的元素。</li></ul><p><strong>其他信息</strong></p><ul><li>**<code>movementX</code>**：自上一次 <code>mousemove</code> 事件以来，鼠标指针在 X 轴上的移动距离。</li><li>**<code>movementY</code>**：自上一次 <code>mousemove</code> 事件以来，鼠标指针在 Y 轴上的移动距离。</li><li>**<code>detail</code>**：事件的点击次数（适用于 <code>click</code> 和 <code>dblclick</code> 等事件）。</li></ul><p><strong>方法</strong></p><ul><li><code>getModifierState(key)</code>：检查指定的修饰键（如 <code>Alt</code>、<code>Shift</code>）是否被按下。</li></ul><p>继承自 <code>UIEvent</code> 和 <code>Event</code> 的属性</p><ul><li>**<code>type</code>**：事件类型（如 <code>&quot;click&quot;</code>、<code>&quot;mousemove&quot;</code>）。</li><li>**<code>target</code>**：事件触发的目标元素。</li><li>**<code>bubbles</code>**：<code>true</code> 表示事件会冒泡。</li><li>**<code>cancelable</code>**：<code>true</code> 表示事件可以被取消。</li><li>**<code>defaultPrevented</code>**：<code>true</code> 表示默认操作已被阻止。</li><li>**<code>timeStamp</code>**：事件触发时的时间戳。</li></ul><p>示例</p><pre><code class="javascript">document.addEventListener(&#39;mousemove&#39;, (event) =&gt; &#123; console.log(&#39;clientX:&#39;, event.clientX);  console.log(&#39;clientY:&#39;, event.clientY); console.log(&#39;screenX:&#39;, event.screenX);  console.log(&#39;button:&#39;, event.button);   console.log(&#39;altKey pressed:&#39;, event.altKey);&#125;);</code></pre><p>这些属性可以帮助开发者获取鼠标的位置信息、按键状态和修饰键等详细信息，以便实现复杂的鼠标交互功能。</p></blockquote><h5 id="Q-6-什么是解构赋值？"><a href="#Q-6-什么是解构赋值？" class="headerlink" title="Q.6:什么是解构赋值？"></a><strong>Q.6:什么是解构赋值？</strong></h5><blockquote><p>在 <code>const &#123; clientX &#125; = event;</code> 和 <code>const clientX = event.clientX;</code> 中，**<code>clientX</code>** 最终的效果是等价的，它们都会从 <code>event</code> 对象中提取 <code>clientX</code> 的值并赋值给一个同名变量。</p><p>但它们的语法和解构方式不同，具体区别如下：</p><p><strong>解构赋值 (<code>const &#123; clientX &#125; = event;</code>)</strong></p><p>这是 <strong>ES6 解构赋值</strong> 的语法，用于从对象中提取属性并赋值给同名变量。</p><pre><code class="javascript">const &#123; clientX &#125; = event;</code></pre><p>等价于：</p><pre><code class="javascript">const clientX = event.clientX;</code></pre><p>优点：</p><ul><li><p>可以同时提取多个属性：</p><pre><code class="javascript"> const &#123; clientX, clientY &#125; = event;</code></pre><p>上述写法相当于：</p><pre><code class="javascript"> const clientX = event.clientX;const clientY = event.clientY;</code></pre></li><li><p>语法更加简洁，适合处理多个属性时使用。</p></li></ul><p><strong>普通赋值 (<code>const clientX = event.clientX;</code>)</strong></p><p>这是更传统的方式，逐个访问对象属性并赋值。</p><pre><code class="javascript">const clientX = event.clientX;</code></pre><p>优点：</p><ul><li>更直观，适合只提取单个属性时。</li></ul><p><strong>总结</strong></p><p>两种写法最终效果是<strong>等价</strong>的，区别在于语法形式和适用场景：</p><ol><li>如果只需要提取单个属性，使用 <code>const clientX = event.clientX;</code> 和 <code>const &#123; clientX &#125; = event;</code> 都可以。</li><li>如果需要提取多个属性，解构赋值更简洁且可读性更好。</li></ol><p>例如：</p><pre><code class="javascript">// 解构赋值const &#123; clientX, clientY &#125; = event;// 传统方式const clientX = event.clientX;const clientY = event.clientY;</code></pre></blockquote><p>这里遇到了新的问题，最初设置<div>依靠的是百分比作为位置信息，在js操作中利用的是px，导致操作繁琐。</p><p>现在尝试把之前的代码进行一定的修改，在一番折腾后写出了以下代码：</p><pre><code class="JS">    let offsetX = 0;    let offsetY = 0;    let nicoDivX =0;    let nicoDivY =0;    let ifDragging = false;    //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量    nicoNoteDiv.addEventListener(&quot;mousedown&quot;,(e) =&gt; &#123;//&quot;mousedown&quot;即监测鼠标点下的事件。        ifDragging = true;        nicoNoteDiv.style.cursor = &quot;move&quot;;        offsetX = e.clientX;        offsetY = e.clientY;        //记录初始鼠标坐标(相对于左上角)        nicoDivY = parseInt(nicoNoteDiv.style.top);        nicoDivX = parseInt(nicoNoteDiv.style.right);        //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）        e.preventDefault();        //用来禁止鼠标拖拽时选中的功能        nicoNoteDiv.addEventListener(&#39;mousemove&#39;,(e)=&gt;&#123;if (ifDragging)&#123;nicoDragging(e)&#125;&#125;);        //通过检测是否拖拽来启用拖拽函数    &#125;);    function nicoDragging(e) &#123;//定义一个Dragging函数 语法：function 函数名(参数) &#123;&#125;        const &#123; clientX, clientY &#125; = e;        //获取当前鼠标坐标        nicoNoteDiv.style.top = `$&#123;nicoDivY+clientY-offsetY&#125;px`;        //$&#123;&#125;表示在字符串中插入函数或变量，但要确保使用反引号`Code`        nicoNoteDiv.addEventListener(&quot;mouseup&quot;,() =&gt;&#123;ifDragging = false;&#125;);        //松开鼠标，停止拖拽    &#125;;</code></pre><p>但是事情并没有那么简单，在松开鼠标后这个玩意还在动，原因如下：</p><blockquote><p> JavaScript 中，监听器（事件监听器）只要没有被明确移除或停止，就会一直监听事件。</p><p> 当你使用诸如 <code>addEventListener</code> 方法在 DOM 元素上绑定一个事件监听器时，这个监听器会一直处于活动状态，直到满足以下条件之一：</p><ol><li><strong>手动移除监听器</strong>：<br>可以使用 <code>removeEventListener</code> 方法来移除监听器。例如：</li></ol><pre><code class="javascript">const button = document.getElementById(&#39;myButton&#39;);function handleClick(event) &#123;    console.log(&#39;Button clicked!&#39;);&#125; // 添加监听器button.addEventListener(&#39;click&#39;, handleClick); // 移除监听器button.removeEventListener(&#39;click&#39;, handleClick);</code></pre><ol start="2"><li><p><strong>元素被移除</strong>：<br>如果绑定了监听器的 DOM 元素被从 DOM 中移除，监听器也会随之停止。</p></li><li><p><strong>一次性监听器</strong>：<br>如果在添加监听器时指定了 <code>&#123; once: true &#125;</code>，监听器会在首次触发后自动移除。例如：</p></li></ol><pre><code class="javascript"> button.addEventListener(&#39;click&#39;, handleClick, &#123; once: true &#125;);</code></pre><p> 父监听器与子监听器的关系</p><p> 如果你指的是在父元素上添加的事件监听器（比如通过事件冒泡机制监听子元素的事件），这种父监听器也会一直监听，除非明确移除。事件冒泡意味着子元素触发的事件会逐层向上传递到父元素，因此父监听器会接收到事件。比如：</p><pre><code class="javascript">const parent = document.getElementById(&#39;parent&#39;);// 父元素监听器parent.addEventListener(&#39;click&#39;, (event) =&gt; &#123;   console.log(&#39;Parent clicked!&#39;, event.target);&#125;);</code></pre><p> 无论是直接点击父元素，还是点击子元素，父元素的监听器都会被触发，除非：</p><ul><li>你使用 <code>stopPropagation()</code> 来阻止冒泡；</li><li>或者通过 <code>removeEventListener</code> 手动移除父监听器。</li></ul><p> 总结</p><ul><li>监听器会持续监听事件，直到手动移除或绑定的 DOM 元素被移除。</li><li>如果没有停止或移除，父监听器会一直监听其范围内的事件冒泡。</li></ul></blockquote><p>也就是说，由于<code>mousemove</code>在<code>mousedown</code>内导致<code>mousedmove</code>一直没法停止。把:</p><pre><code class="JS">nicoNoteDiv.addEventListener(&#39;mousemove&#39;,(e)=&gt;&#123;if (ifDragging)&#123;nicoDragging(e)&#125;&#125;); nicoNoteDiv.addEventListener(&quot;mouseup&quot;,() =&gt;&#123;ifDragging = false;&#125;);</code></pre><p>插在外面就行了。</p><p>最终成品：</p><pre><code class="JS">        let offsetX = 0;        let offsetY = 0;        let nicoDivX =0;        let nicoDivY =0;        let ifDragging = false;        //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量        nicoNoteDiv.addEventListener(&quot;mousedown&quot;,(e) =&gt; &#123;//&quot;mousedown&quot;即监测鼠标点下的事件。            ifDragging = true;            offsetX = e.clientX;            offsetY = e.clientY;            //记录初始鼠标坐标(相对于左上角)            nicoDivY = parseInt(nicoNoteDiv.style.top);            nicoDivX = parseInt(nicoNoteDiv.style.right);            //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）            e.preventDefault();            //用来禁止鼠标拖拽时选中的功能        &#125;);        nicoNoteDiv.addEventListener(&#39;mousemove&#39;,(e)=&gt;&#123;            if(ifDragging)&#123;                const &#123; clientX, clientY &#125; = e;                //获取当前鼠标坐标                nicoNoteDiv.style.top = `$&#123;nicoDivY+clientY-offsetY&#125;px`;                nicoNoteDiv.style.right = `$&#123;nicoDivX-clientX+offsetX&#125;px`;                //$&#123;&#125;表示在字符串中插入函数或变量，但要确保使用反引号`Code `            &#125;         &#125;);        nicoNoteDiv.addEventListener(&quot;mouseup&quot;,() =&gt;&#123;ifDragging = false;&#125;);        //松开鼠标，停止拖拽</code></pre><p>考虑到这个玩意可以应用到之前那个图标上，我们把它封装成一个函数。</p><p>由于光标太快会划出<code>element</code>，有时候<code>mousedown</code>事件会停止监听，改变策略把<code>mousemove</code>和<code>mouseup</code>监听对象改为<code>document</code>，即：<code> document.addEventListener()</code>。</p><p>这里有个新问题：</p><h5 id="Q-7如何在拖拽的同时不触发点击？"><a href="#Q-7如何在拖拽的同时不触发点击？" class="headerlink" title="Q.7如何在拖拽的同时不触发点击？"></a><strong>Q.7如何在拖拽的同时不触发点击？</strong></h5><blockquote><p>方法一：通过 <code>mousemove</code> 判断是否发生拖拽</p><p>可以在 <code>mousedown</code> 和 <code>mousemove</code> 中记录鼠标的移动距离，并在 <code>mouseup</code> 时判断是否是一次有效的拖拽操作。如果移动的距离超过一定阈值，就认为是拖拽而非点击。</p><pre><code class="javascript">let isDragging = false;const element = document.querySelector(&quot;#draggable&quot;);element.addEventListener(&quot;mousedown&quot;, (e) =&gt; &#123; isDragging = false; // 重置拖拽状态 const startX = e.clientX; const startY = e.clientY; const onMouseMove = (e) =&gt; &#123;     if (Math.abs(e.clientX - startX) &gt; 5 || Math.abs(e.clientY - startY) &gt; 5) &#123;         isDragging = true;     &#125; &#125;; const onMouseUp = () =&gt; &#123;     document.removeEventListener(&quot;mousemove&quot;, onMouseMove);     document.removeEventListener(&quot;mouseup&quot;, onMouseUp); &#125;; document.addEventListener(&quot;mousemove&quot;, onMouseMove); document.addEventListener(&quot;mouseup&quot;, onMouseUp);&#125;);element.addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (isDragging) &#123;     e.preventDefault(); // 如果是拖拽，不触发点击 &#125;&#125;);</code></pre><p>方法二：使用 <code>drag</code> 和 <code>dragstart</code> 事件</p><p>如果使用 HTML5 的拖放 API，可以利用 <code>drag</code> 和 <code>dragstart</code> 来区分拖拽和点击。</p><pre><code class="javascript">let isDragging = false;const element = document.querySelector(&quot;#draggable&quot;);element.addEventListener(&quot;dragstart&quot;, () =&gt; &#123; isDragging = true; // 标记为拖拽&#125;);element.addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (isDragging) &#123;     e.preventDefault(); // 阻止点击事件     isDragging = false; // 重置状态 &#125;&#125;);</code></pre><p>方法三：直接在 <code>click</code> 中判断拖拽状态</p><p>如果你的拖拽实现中没有其他复杂的状态，也可以简单地在 <code>click</code> 事件中检查。</p><pre><code class="javascript">let isDragging = false;element.addEventListener(&quot;mousedown&quot;, () =&gt; &#123; isDragging = false;&#125;);element.addEventListener(&quot;mousemove&quot;, () =&gt; &#123; isDragging = true; // 如果发生移动，标记为拖拽&#125;);element.addEventListener(&quot;mouseup&quot;, () =&gt; &#123; setTimeout(() =&gt; (isDragging = false), 0); // 延迟重置状态&#125;);element.addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (isDragging) &#123;     e.preventDefault(); &#125;&#125;);</code></pre><p>方法四：CSS <code>pointer-events</code> 阻止点击</p><p>如果拖拽操作是通过 CSS 结合 JavaScript 实现，可以在拖拽时临时禁用 <code>pointer-events</code>。</p><pre><code class="javascript">const element = document.querySelector(&quot;#draggable&quot;);element.addEventListener(&quot;mousedown&quot;, () =&gt; &#123; element.style.pointerEvents = &quot;none&quot;; // 禁止点击&#125;);element.addEventListener(&quot;mouseup&quot;, () =&gt; &#123; setTimeout(() =&gt; &#123;     element.style.pointerEvents = &quot;auto&quot;; // 恢复点击 &#125;, 0);&#125;);</code></pre><p>总结</p><p>最推荐的方法是 <strong>方法一</strong>，结合鼠标的移动距离判断是否是拖拽，因为它适用于大多数拖拽实现场景，且与 HTML5 拖放 API 或 CSS 的依赖性较低。</p></blockquote><p>这里采用方法四，而 mouseup 的监听对象一定为 document 才有效，最后将right改为更易操作的的left，封装后的函数如下：</p><pre><code class="js">    function letWeDrag(dragDiv)&#123;        let offsetX = 0;        let offsetY = 0;        let nicoDivX =0;        let nicoDivY =0;        let ifDragging = false;        //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量        dragDiv.addEventListener(&quot;mousedown&quot;,(e) =&gt; &#123;//&quot;mousedown&quot;即监测鼠标点下的事件。            ifDragging = true;            offsetX = e.clientX;            offsetY = e.clientY;            //记录初始鼠标坐标(相对于左上角)            nicoDivY = parseInt(dragDiv.style.top);            nicoDivX = parseInt(dragDiv.style.left);            //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）            e.preventDefault();            //用来禁止鼠标拖拽时选中的功能        &#125;);        document.addEventListener(&#39;mousemove&#39;,(e)=&gt;&#123;            if(ifDragging)&#123;                const &#123; clientX, clientY &#125; = e;                //获取当前鼠标坐标                dragDiv.style.top = `$&#123;nicoDivY+clientY-offsetY&#125;px`;                dragDiv.style.left = `$&#123;nicoDivX+clientX-offsetX&#125;px`;                //$&#123;&#125;表示在字符串中插入函数或变量，但要确保使用反引号`Code`                dragDiv.style.pointerEvents = &quot;none&quot;;                //禁止单击，防止拖拽同时点击。            &#125;        &#125;);        document.addEventListener(&quot;mouseup&quot;,() =&gt;&#123;            ifDragging = false;            dragDiv.style.pointerEvents = &quot;auto&quot;; // 恢复点击        &#125;);        //松开鼠标，停止拖拽    &#125;</code></pre><p>由于将right换用left，为了使图标继续在右侧，我们应该获取屏幕的宽度。</p><h5 id="Q-8：如何获取屏幕的宽度？"><a href="#Q-8：如何获取屏幕的宽度？" class="headerlink" title="Q.8：如何获取屏幕的宽度？"></a>Q.8：如何获取屏幕的宽度？</h5><p>在 JavaScript 中，可以使用以下方法获取屏幕的 <strong>像素信息</strong>：</p><blockquote><p><strong>1. 获取屏幕的宽度和高度（<code>window.screen</code>）</strong></p><p>通过 <code>window.screen</code> 对象，可以获取屏幕的物理分辨率：</p><pre><code class="javascript">console.log(&quot;屏幕宽度：&quot; + window.screen.width + &quot;px&quot;);console.log(&quot;屏幕高度：&quot; + window.screen.height + &quot;px&quot;);</code></pre><ul><li><code>window.screen.width</code>：屏幕的宽度（像素）。</li><li><code>window.screen.height</code>：屏幕的高度（像素）。</li></ul><p><strong>2. 获取可用工作区域的尺寸</strong></p><p><code>window.screen.availWidth</code> 和 <code>window.screen.availHeight</code> 用于获取屏幕除去任务栏或工具栏后的可用尺寸：</p><pre><code class="javascript">javascript复制代码console.log(&quot;可用宽度：&quot; + window.screen.availWidth + &quot;px&quot;);console.log(&quot;可用高度：&quot; + window.screen.availHeight + &quot;px&quot;);</code></pre><p><strong>3. 获取浏览器窗口的尺寸</strong></p><p>通过 <code>window.innerWidth</code> 和 <code>window.innerHeight</code> 可以获取浏览器窗口的内容区域大小（不包含工具栏或边框）：</p><pre><code class="javascript">javascript复制代码console.log(&quot;窗口宽度：&quot; + window.innerWidth + &quot;px&quot;);console.log(&quot;窗口高度：&quot; + window.innerHeight + &quot;px&quot;);</code></pre><p><strong>4. 获取设备像素比（<code>devicePixelRatio</code>）</strong></p><p><code>window.devicePixelRatio</code> 返回设备像素比（DPR），表示物理像素与 CSS 像素的比值：</p><pre><code class="javascript">console.log(&quot;设备像素比：&quot; + window.devicePixelRatio);</code></pre><p>例如：</p><ul><li>如果 <code>devicePixelRatio = 2</code>，表示 1 个 CSS 像素对应 2 个物理像素。</li><li>通常高分辨率设备（如 Retina 屏幕）会有较高的 DPR 值。</li></ul><p><strong>5. 获取页面滚动的像素位置</strong></p><p>通过 <code>window.scrollX</code> 和 <code>window.scrollY</code> 可以获取页面的水平和垂直滚动位置：</p><pre><code class="javascript">console.log(&quot;水平滚动位置：&quot; + window.scrollX + &quot;px&quot;);console.log(&quot;垂直滚动位置：&quot; + window.scrollY + &quot;px&quot;);</code></pre><p><strong>6. 获取元素的大小和位置</strong></p><p>如果要获取某个 HTML 元素的宽度和高度，可以使用 <code>getBoundingClientRect()</code>：</p><pre><code class="javascript">const element = document.querySelector(&quot;#myElement&quot;);const rect = element.getBoundingClientRect();console.log(`元素宽度：$&#123;rect.width&#125;px, 高度：$&#123;rect.height&#125;px`);console.log(`元素位置：左=$&#123;rect.left&#125;px, 上=$&#123;rect.top&#125;px`);</code></pre><p><strong>总结</strong></p><ul><li>屏幕尺寸：<code>window.screen.width</code> 和 <code>window.screen.height</code></li><li>可用区域：<code>window.screen.availWidth</code> 和 <code>window.screen.availHeight</code></li><li>浏览器窗口：<code>window.innerWidth</code> 和 <code>window.innerHeight</code></li><li>DPR：<code>window.devicePixelRatio</code></li><li>滚动位置：<code>window.scrollX</code> 和 <code>window.scrollY</code></li></ul></blockquote><p>这里我们用到<code>window.innerWidth</code>就可以了。</p><p>这里我们还要保证窗口调节时，它的位置能一同调节，用以下函数，达到这一效果：</p><pre><code class="JS">window.top.addEventListener(&#39;resize&#39;, () =&gt; &#123;//监听顶层窗口调节大小事件    const element = document.getElementById(&quot;nicoBt&quot;);    const elementWidth = element.offsetWidth;    const viewportWidth = window.innerWidth;    element.style.left = (viewportWidth - elementWidth-10) + &quot;px&quot;;    nicoNoteDiv.style.top = `$&#123;parseInt(nicoButton.style.top)&#125;px`;    nicoNoteDiv.style.left = `$&#123;parseInt(nicoButton.style.left)-parseInt(nicoNoteDiv.style.width)&#125;px`;&#125;);</code></pre><p>2024&#x2F;12&#x2F;12</p><hr><h4 id="②拖拽调节大小"><a href="#②拖拽调节大小" class="headerlink" title="②拖拽调节大小"></a>②拖拽调节大小</h4><p>只需要在CSS中添加：</p><pre><code class="CSS">resize: both;/*允许元素在x、y两个方向上调整大小*/overflow: auto;/*显示滚动条*/</code></pre><p>就可以实现简单的调整大小,参考<a href="https://blog.csdn.net/qq_44327851/article/details/135040288#:">css resize-CSDN博客</a>。</p><p><strong>注意的是，能正常调整的条件是：CSS样式中，元素的位置描述使用 top 与 left。</strong></p><p>但是我们要让它有最大最小的限制，思路是通过监听鼠标，通过JS来限制大小。</p><pre><code class="js">document.addEventListener(&quot;mouseup&quot;,()=&gt;&#123;    if(parseInt(nicoNoteDiv.style.width)&lt;200)&#123; nicoNoteDiv.style.width=&quot;200px&quot;;&#125;;    if(parseInt(nicoNoteDiv.style.height)&lt;40)&#123; nicoNoteDiv.style.height=&quot;40px&quot;;&#125;&#125;);</code></pre><h4 id="③组合起来！"><a href="#③组合起来！" class="headerlink" title="③组合起来！"></a>③组合起来！</h4><p>由于这两者判定位置重合，因此我们应该使用一定的嵌套。</p><p>这时我们就要对 UI 进行一定的规划：也就是流出上方一条允许拖拽，其余部分无法拖拽。</p><p>让外层元素调节大小，内层元素负责拖动，这样一个东西就做好了！</p><h3 id="8、引入-Vditor"><a href="#8、引入-Vditor" class="headerlink" title="8、引入 Vditor"></a>8、引入 Vditor</h3><h4 id="JS-与-CSS-的引入"><a href="#JS-与-CSS-的引入" class="headerlink" title="JS 与 CSS 的引入"></a>JS 与 CSS 的引入</h4><p>终于捣鼓完这个框框了，接下来我们要在这个容器中引入文本编辑器。</p><p>使用开源项目 <a href="https://github.com/Vanessa219/vditor">Vditor</a> 来作为文本编辑器 ,根据开发者文档尝试在 HTML 中引入 vditor 的 JS 与 CSS 。</p><pre><code class="html">&lt;!-- ⚠️生产环境请指定版本号，如 https://unpkg.com/vditor@x.x.x/dist... --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/vditor/dist/index.css&quot; /&gt;&lt;script src=&quot;https://unpkg.com/vditor/dist/index.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>把这行代码写入<head>中：</p><pre><code class="js">    document.querySelector(&quot;head&quot;).insertAdjacentHTML(&quot;afterbegin&quot;,headVditorCode);</code></pre><h5 id="Q-9：之前讲过用-require加载脚本，这里可以那样做吗？"><a href="#Q-9：之前讲过用-require加载脚本，这里可以那样做吗？" class="headerlink" title="Q.9：之前讲过用@require加载脚本，这里可以那样做吗？"></a><strong>Q.9：之前讲过用<code>@require</code>加载脚本，这里可以那样做吗？</strong></h5><blockquote><p>可以，且<strong>更推荐使用<code>@require</code>的方式</strong>，因为如果你在插入资源后立即使用 Vditor，可能会因为资源未加载完成而报错，并且动态插入 HTML 字符串不够直观，可能会增加代码阅读和维护的难度。</p><p>但是**<code>@require</code>只能用来加载 JS 而不能用于 CSS **使用<code>GM_addStyle</code>可以解决这一问题。</p><pre><code class="js">// ==UserScript==// @name         Vditor Integration with CSS// @namespace    http://tampermonkey.net/// @version      1.0// @description  Integrate Vditor// @author       Your Name// @match        *://*/*// @require      https://cdn.jsdelivr.net/npm/vditor/dist/index.min.js// @grant        GM_addStyle// ==/UserScript==// 使用 GM_addStyle 插入 CSS 样式GM_addStyle(`@import url(&#39;https://cdn.jsdelivr.net/npm/vditor/dist/index.css&#39;);`);</code></pre><p>如果你坚持使用动态插入方式，建议优化为分步加载，避免时序问题：</p><pre><code class="javascript">// 动态加载 CSSvar link = document.createElement(&#39;link&#39;);link.rel = &#39;stylesheet&#39;;link.href = &#39;https://unpkg.com/vditor/dist/index.css&#39;;document.head.appendChild(link);// 动态加载 JSvar script = document.createElement(&#39;script&#39;);script.src = &#39;https://unpkg.com/vditor/dist/index.min.js&#39;;script.onload = function () &#123;// 确保 Vditor 加载完成后再初始化new Vditor(&#39;editor&#39;, &#123;  height: 300,  placeholder: &#39;Write something...&#39;,&#125;);&#125;;document.head.appendChild(script);</code></pre><p>这种方式更易维护，且避免 HTML 字符串操作的潜在问题。</p></blockquote><h4 id="Vditor-的初始化"><a href="#Vditor-的初始化" class="headerlink" title="Vditor 的初始化"></a>Vditor 的初始化</h4><p>为了理解如何引入 Vditor ，我需要花一点时间来对文档进行理解：</p><blockquote><p>首先，Vditor 定义了一个名为 <code>Vditor</code> 的类。</p><p>这个类包含若干属性，最主要的是 id 和 options。</p><p>我们首先要创建一个这个”类“的”实例“，可以理解为所谓”实例“就是一个这个”类“的变量。</p><p>创建实例的语法为： <code>new  类名(参数1，参数2。。。)</code></p><p>在这个<code>Vditor</code>就应该写成：<code>new Vditor(id,options,....)</code></p><p>这个id是一个字符串，而这个 options 里面包含了许多属性，我们把这些属性用大括号括起来。</p><p>另外 options 还有诸如 <code>options.toolbar</code> <code>options.counter</code> 的子属性他们的书写方式文档中也有写。</p><p>此外，我们这个类中还有一些”方法“<code>methods</code>供我们操作这些实例。</p></blockquote><p>第一次尝试引入：</p><pre><code class="js">    const vditor = new Vditor(&quot;nicoVditor&quot;,&#123;        placeholder: &#39;Write something here...&#39;,        toolbar: [&#39;emoji&#39;, &#39;headings&#39;, &#39;bold&#39;, &#39;italic&#39;, &#39;strike&#39;, &#39;link&#39;, &#39;list&#39;],    &#125;)</code></pre><p>显示 nicoVditor Not found ，推断是初始化代码在 nicoVditor 被添加之前就已经运行，通过调整代码逻辑，成功解决该问题。</p><p>再次运行显示：<code>GET https://unpkg.com/vditor@3.10.8/dist/js/i18n/zh_CN.js net::ERR_ABORTED 404 (Not Found)</code></p><p>怀疑是脚本无权访问此文件，在元属性中添加<code>// @require      https://unpkg.com/vditor@3.10.8/dist/js/i18n/zh_CN.js</code>成功运行。</p><p>接下来就是简单的调试一下！</p><p>2024&#x2F;12&#x2F;13</p><hr><h3 id="9、尝试与修复-CDN-被-CSP-拦截的问题-待解决"><a href="#9、尝试与修复-CDN-被-CSP-拦截的问题-待解决" class="headerlink" title="9、尝试与修复 CDN 被 CSP 拦截的问题(待解决)"></a>9、尝试与修复 CDN 被 CSP 拦截的问题(待解决)</h3><p>发现无法在 Github 中初始化，询问AI后得到以下解答：</p><blockquote><p>这个错误消息表示，浏览器拒绝加载样式表 <code>https://cdn.jsdelivr.net/npm/vditor/dist/index.css</code>，因为它违反了当前页面的内容安全策略（Content Security Policy，CSP）指令。具体来说，CSP 指令 <code>style-src &#39;unsafe-inline&#39; github.githubassets.com</code> 限制了可以加载样式表的来源，而 <code>jsdelivr.net</code> 不在允许的来源列表中。</p><h3 id="可能导致该错误的原因"><a href="#可能导致该错误的原因" class="headerlink" title="可能导致该错误的原因"></a>可能导致该错误的原因</h3><ol><li><strong>严格的内容安全策略</strong>：GitHub 页面设置了严格的 CSP，限制了可以加载样式表的来源，以提高安全性。</li><li><strong>外部样式表来源不被允许</strong>：当前 CSP 只允许从 <code>github.githubassets.com</code> 加载样式表，而不允许从 <code>jsdelivr.net</code> 加载。</li></ol></blockquote><p>搜索方案，发现某些项目可以绕过这一限制：<a href="https://github.com/guansss/webpack-monkey">guansss&#x2F;webpack-monkey：一个 webpack 插件，用于使用现代工作流程开发您的用户脚本，具有 HMR、元生成等功能。</a></p><h4 id="使用-webpack-monkey"><a href="#使用-webpack-monkey" class="headerlink" title="使用 webpack-monkey"></a>使用 webpack-monkey</h4><p>用 npm 或 yarn（install 替换为 add） 均可。（超时挂梯子，给命令台走代理）</p><h5 id="对该项目进行安装与初始化："><a href="#对该项目进行安装与初始化：" class="headerlink" title="对该项目进行安装与初始化："></a>对该项目进行安装与初始化：</h5><pre><code>npm init -ynpm install webpack webpack-cli webpack-dev-server webpack-monkey  --save-dev</code></pre><h5 id="创建以下目录："><a href="#创建以下目录：" class="headerlink" title="创建以下目录："></a>创建以下目录：</h5><pre><code>.├── dist│   └── hello.user.js├── src│   ├── index.js│   └── meta.js├── webpack.config.js└── package.json</code></pre><h5 id="编写脚本："><a href="#编写脚本：" class="headerlink" title="编写脚本："></a>编写脚本：</h5><ul><li>在 <code>src/index.js</code> 中编写脚本逻辑（不包含元数据）</li></ul><pre><code class="js">GM_log(&quot;Hello world!&quot;);if (module.hot) &#123;  module.hot.monkeyReload();&#125;</code></pre><ul><li>在 <code>src/meta.js</code> 中定义脚本的元数据</li></ul><pre><code class="JS">module.exports = &#123;  name: &quot;Hello world&quot;,  version: &quot;1.0.0&quot;,  match: [&quot;*://example.com/&quot;],&#125;;</code></pre><ul><li>在 <code>webpack.config.js</code> 中配置 <code>webpack-monkey</code></li></ul><pre><code class="JS">const path = require(&quot;path&quot;)const &#123; monkey &#125; = require(&quot;webpack-monkey&quot;)//module.exports = monkey(&#123;  entry: &#39;./src/index.js&#39;,//输入文件  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),//输出目录  &#125;,&#125;)</code></pre><h5 id="配置构建脚本"><a href="#配置构建脚本" class="headerlink" title="配置构建脚本"></a>配置构建脚本</h5><p>在 <code>package.json</code> 中添加构建脚本，相当于添加了命令台指令：</p><pre><code class="JS">&#123;  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack serve --mode development&quot;,//调试工具    &quot;build&quot;: &quot;webpack --mode production&quot;//生成工具  &#125;&#125;</code></pre><h5 id="生成用户脚本"><a href="#生成用户脚本" class="headerlink" title="生成用户脚本"></a>生成用户脚本</h5><pre><code>npm build</code></pre><p>会在 dist 中生成用户脚本。</p><h5 id="尝试绕过CSP"><a href="#尝试绕过CSP" class="headerlink" title="尝试绕过CSP"></a>尝试绕过CSP</h5><p>webpack-monkey 的原理是：通过将需要外部加载的脚本与CSS样表与油猴脚本一起打包到一个文件，从而解决了 CSP 的问题。</p><p>首先，安装用于打包 CSS 与 JS 的 loader：</p><pre><code class="powershell">npm install css-loader style-loader --save-dev#用于加载CSSnpm install script-loader --save-dev#用于加载JS</code></pre><p>在 Webpack 配置中，添加相关配置：</p><pre><code class="JS">const path = require(&quot;path&quot;);const &#123; monkey &#125; = require(&quot;webpack-monkey&quot;);const TerserPlugin = require(&quot;terser-webpack-plugin&quot;); // 引入 terser-webpack-pluginmodule.exports = monkey(&#123;  entry: &#39;./src/index.js&#39;,//输入文件  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),//输出目录  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i, // 匹配所有 .css 文件        use: [&quot;style-loader&quot;, &quot;css-loader&quot;], // 使用 style-loader 和 css-loader 处理      &#125;,      &#123;        test: /external-script\.js$/,  // 匹配外部 JS 脚本        use: &quot;script-loader&quot;,  // 使用 script-loader 打包      &#125;,    ],  &#125;,&#125;);</code></pre><p>将脚本和CSS下载到本地后，在 index.js 文件中引入本地的脚本：</p><pre><code class="JS">import &quot;./CSS/index.css&quot;;import &quot;./JS/index.min.js&quot;;</code></pre><p>运行后生成了打包后的脚本，但无法运行，反思后认为原因如下：</p><blockquote><p>webpack打包的js中又通过字符串操作引用了新的URL，而新的URL仍然不能绕过CSP。</p><p>并且不同的 JS 之间的相互依赖限制了运行顺序，运行顺序不当也会出现这种情况。</p></blockquote><h4 id="替代的解决方案"><a href="#替代的解决方案" class="headerlink" title="替代的解决方案"></a>替代的解决方案</h4><ol><li>手动追踪所有的URL将他们修改并打包。缺点是耗时长且可维护性极低。（不可行）</li><li>使用拓展程序来手动禁用 CSP。</li></ol><h4 id="无法加载的其他未知原因与局限性分析"><a href="#无法加载的其他未知原因与局限性分析" class="headerlink" title="无法加载的其他未知原因与局限性分析"></a>无法加载的其他未知原因与局限性分析</h4><p>在某些页面不是因为 CSP 而无法初始化 Vditor (经过测试，所有搜索引擎的“搜索结果”页面都不能正常载入)原因暂时未知。</p><p>这类问题暴露出了油猴作为脚本运行器的局限性，或许我们可以开发<strong>浏览器插件，而不是油猴脚本。</strong></p><p>总结就是，关于这个问题：</p><div class="poem"><p><span lang="ja"><big><big><big><big>失敗した失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した<br>あたしは失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した<br>失敗した失敗した失敗した失敗した失敗した</big></big></big></big></span></p></div><p>2024&#x2F;12&#x2F;13</p><hr><h3 id="10、储存编辑的文本"><a href="#10、储存编辑的文本" class="headerlink" title="10、储存编辑的文本"></a>10、储存编辑的文本</h3><p>参考：<a href="https://www.runoob.com/html/html5-web-api-indexeddb.html">HTML5 Web IndexedDB 数据库 | 菜鸟教程</a></p><p>Vditor 提供了把文件导出到本地的功能，但不能实现将笔记保存在当前网页的功能。</p><p>由于浏览器的网页存在严格的沙箱机制，因此我们无法利用浏览器脚本操作本地文件，自然也就不能利用脚本把文件保存在本地。</p><p>但是浏览器提供了 IndexedDB 这一机制，允许我们储大量结构化数据。它是异步的，可以存储较大的数据对象，适合需要存储大量数据或进行复杂查询的场景。因此我们甚至可以实现自动保存，历史版本管理的功能。</p><h4 id="获取文本内容"><a href="#获取文本内容" class="headerlink" title="获取文本内容"></a>获取文本内容</h4><p>Vditor 提供的工具中为我们提供了获取文本内容的 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>exportJSON(markdown: string)</td><td>根据 Markdown 获取对应 JSON</td></tr><tr><td>getValue()</td><td>获取 Markdown 内容</td></tr><tr><td>getHTML()</td><td>获取 HTML 内容</td></tr></tbody></table><h4 id="创建-IndexedDB"><a href="#创建-IndexedDB" class="headerlink" title="创建 IndexedDB"></a>创建 IndexedDB</h4><pre><code class="js">const request = indexedDB.open(&quot;VditorHistoryDB&quot;, 1);//创建版本号为1的IndexedDBlet db;</code></pre><p>初始化：</p><pre><code class="js">request.onupgradeneeded = e =&gt; &#123;    db = e.target.result;    //表示成功打开的数据库实例。    if (!db.objectStoreNames.contains(&quot;history&quot;)) &#123;        db.createObjectStore(&quot;history&quot;, &#123; keyPath: &quot;id&quot; &#125;);        //如果没有创建对象储存，则创建一个&quot;history&quot;对象储存。        //而每一条主字段的标识为id，也就是我们可以在之后给每个字段添加id，作为标识。IndexedDB 会根据这个属性对记录进行索引。    &#125;&#125;;</code></pre><p>这里的<code>onupgradeneeded</code>代表数据库初次创建或版本号更新时执行函数。</p><p>**<code>db.objectStoreNames</code>**：一个类似数组的对象，列出了当前数据库中所有已存在的对象存储（表）。</p><p>而**<code>contains(&quot;history&quot;)</code>**：检查是否已存在名为 <code>&quot;history&quot;</code> 的对象存储。</p><p>如果数据库已经创建了，则：</p><pre><code class="JS">request.onsuccess = e =&gt; &#123;    db = e.target.result;&#125;;</code></pre><p><code>onsuccess</code>表示成功加载执行函数。</p><p><strong>出现的问题：<code>onsuccess</code>无法正确触发</strong></p><p>既不出发<code>onsuccess</code>也不触发<code>onerror</code>，只能触发<code>onupgradeneeded</code>，且控制台没有输出，原因暂时未知，所以无法修复。</p><p>这里采用替代方案每次进入都改变版本号来触发<code>onupgradeneeded</code>。</p><h4 id="将内容保存至数据库"><a href="#将内容保存至数据库" class="headerlink" title="将内容保存至数据库"></a>将内容保存至数据库</h4><p>这里使用数据库实例的 <code>transaction()</code> 方法创建一个事务：</p><pre><code class="JS">const transaction = db.transaction(storeNames, mode);</code></pre><p>**<code>storeNames</code>**：</p><ul><li>可以是一个字符串（单个对象存储的名称）或数组（多个对象存储的名称）。</li><li>决定事务可以操作哪些对象存储。例如，<code>&quot;history&quot;</code> 表示事务将操作名为 <code>&quot;history&quot;</code> 的存储。</li></ul><p>**<code>mode</code>**：</p><ul><li>事务的模式，定义了可以执行的操作：<ul><li><code>&quot;readonly&quot;</code>：只读事务，只允许读取数据。</li><li><code>&quot;readwrite&quot;</code>：读写事务，允许读取和修改数据。</li></ul></li></ul><p>通过 <code>transaction.objectStore()</code> 获取特定的存储，操作其中的数据。</p><pre><code class="js">function saveContent() &#123;    const content = nicoVditor.getValue();//获取 Markdown 内容    const timestamp = Date.now(); // 时间戳作为 ID    const transaction = db.transaction(&quot;history&quot;, &quot;readwrite&quot;);//创建一个操作 &quot;history&quot; 存储的读写事务。    const store = transaction.objectStore(&quot;history&quot;);// 获取 &quot;history&quot; 对象存储    store.put(&#123; id: timestamp, content: content, savedAt: new Date().toLocaleString() &#125;);//向&quot;history&quot; 存储中放入一个id为时间戳，内容为 Markdown 内容，保存的时间为当前时间的内容。//savedAt 是一个字段，用于记录保存的时间。而new Date().toLocaleString() 是 JavaScript 的方法，返回当前时间的本地化格式（例如 2024/12/15 10:30:45）    transaction.oncomplete = () =&gt; &#123;        alert(&quot;内容已保存！&quot;);    &#125;;    transaction.onerror = (event) =&gt; &#123;        console.error(&quot;保存失败&quot;, event.target.error);    &#125;;&#125;</code></pre><p>最后在工具栏插入一个按钮：</p><pre><code class="js">&#123; name: &#39;nicoSave&#39;, tipPosition: &#39;s&#39;, tip: &#39;保存到浏览器&#39;, className: &#39;right&#39;, icon: ``, click () &#123;saveContent()&#125;,&#125;</code></pre><p><strong>出现的问题：<code>getValue()</code>未定义（已解决）</strong></p><p>原因是无法引入<code>method</code>脚本文件，引入后问题依旧存在，替代方案：</p><pre><code class="js">document.querySelector(&quot;#nicoVditor &gt; div.vditor-content &gt; div.vditor-ir&quot;).innerHTML;//获取 HTML 内容</code></pre><p><strong>出错原因：在 saveContent() 函数中 Vditor 未被定义</strong></p><p><strong>解决方法：将  Vditor 作为参数传入函数中</strong></p><h4 id="返回历史版本"><a href="#返回历史版本" class="headerlink" title="返回历史版本"></a>返回历史版本</h4><pre><code class="js">    function showHistory(ifFirst) &#123;        const transaction = db.transaction(&quot;history&quot;, &quot;readonly&quot;);//创建读取事务的实例        const store = transaction.objectStore(&quot;history&quot;);//获取对象储存的实例        const request = store.getAll();         request.onsuccess = (event) =&gt; &#123;             const history = event.target.result; // 确保在请求成功后访问 result 属性             &#125;;        history.sort((a, b) =&gt; b.id - a.id);// 按 ID（即时间戳）降序排序        if(ifFirst)&#123;document.querySelector(&quot;#nicoVditor &gt; div.vditor-content &gt; div.vditor-ir&quot;).innerHTML = history[0].content;ifFirst=true;&#125;        else&#123;return history;&#125;    &#125;</code></pre><p><strong>这里直接使用修改<code>.innerHTML</code>导致返回保存后无法被继续编辑，改用<code>setValue()</code>重构代码</strong></p><p>点击之后呼出弹窗</p><pre><code class="JS">    function showHistoryDialog(history) &#123;        // 如果已有弹窗，先移除        //const existingDialog = document.querySelector(&quot;#history-dialog&quot;);        //if (existingDialog) existingDialog.remove();        // 创建弹窗容器        const dialog = document.createElement(&quot;div&quot;);        dialog.id = &quot;history-dialog&quot;;        dialog.style.position = &quot;fixed&quot;;        dialog.style.top = &quot;50%&quot;;        dialog.style.left = &quot;50%&quot;;        dialog.style.transform = &quot;translate(-50%, -50%)&quot;;        dialog.style.background = &quot;#fff&quot;;        dialog.style.border = &quot;1px solid #ddd&quot;;        dialog.style.padding = &quot;15px&quot;;        dialog.style.boxShadow = &quot;0px 2px 10px rgba(0, 0, 0, 0.3)&quot;;        dialog.style.zIndex = &quot;1000&quot;;        dialog.style.maxHeight = &quot;300px&quot;;        dialog.style.overflowY = &quot;auto&quot;;        // 弹窗标题        const title = document.createElement(&quot;h3&quot;);        title.innerText = &quot;历史记录&quot;;        title.style.marginTop = &quot;0&quot;;        dialog.appendChild(title);        // 遍历历史记录，添加按钮        history.forEach((item, index) =&gt; &#123;            const button = document.createElement(&quot;button&quot;);            button.innerText = `$&#123;index + 1&#125;. $&#123;item.savedAt&#125;`;            button.style.display = &quot;block&quot;;            button.style.marginBottom = &quot;10px&quot;;            button.style.width = &quot;100%&quot;;            // 点击按钮时写入内容            button.onclick = () =&gt; &#123;                document.querySelector(&quot;#nicoVditor &gt; div.vditor-content &gt; div.vditor-ir&quot;).innerHTML = item.content;                console.log(`已恢复历史记录: $&#123;item.savedAt&#125;`);                dialog.remove(); // 关闭弹窗            &#125;;            dialog.appendChild(button);        &#125;);        // 关闭按钮        const closeButton = document.createElement(&quot;button&quot;);        closeButton.innerText = &quot;关闭&quot;;        closeButton.style.marginTop = &quot;10px&quot;;        closeButton.style.width = &quot;100%&quot;;        closeButton.onclick = () =&gt; dialog.remove();        dialog.appendChild(closeButton);        // 将弹窗插入到页面        document.body.appendChild(dialog);    &#125;</code></pre><p>但是因为 <code>showHistory</code> 函数是异步（允许它之后的代码先运行）的，而你在调用 <code>showHistory</code> 函数时期望立即获得结果。你需要确保在 <code>request.onsuccess</code> 事件处理程序中处理结果。</p><h5 id="Q10-异步执行的函数如何获取返回值？"><a href="#Q10-异步执行的函数如何获取返回值？" class="headerlink" title="Q10.异步执行的函数如何获取返回值？"></a>Q10.异步执行的函数如何获取返回值？</h5><blockquote><p>在 JavaScript 中，异步函数的返回值无法直接通过同步方式获取，因为异步操作（如网络请求、定时器等）需要时间完成。因此，需要通过以下几种方法来获取异步函数的返回值：</p><ol><li><strong><code>Promise</code> 和 <code>then()</code></strong></li></ol><p>当异步函数返回一个 <strong>Promise</strong> 对象时，可以通过 <code>.then()</code> 方法来处理返回值。</p><p>示例代码</p><pre><code class="javascript">function asyncFunction() &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&quot;异步返回值&quot;);        &#125;, 1000); // 模拟异步操作，1秒后返回    &#125;);&#125;// 使用 then() 获取返回值asyncFunction().then((result) =&gt; &#123;    console.log(&quot;获取到的返回值:&quot;, result);&#125;);</code></pre><ol start="2"><li><strong><code>async/await</code></strong></li></ol><p><code>async/await</code> 是对 <code>Promise</code> 的语法糖，使得异步代码更像同步代码，更易于理解和编写。</p><p>示例代码</p><pre><code class="javascript">async function asyncFunction() &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&quot;异步返回值&quot;);        &#125;, 1000); // 模拟异步操作    &#125;);&#125;// 使用 async/await 获取返回值async function getValue() &#123;    const result = await asyncFunction();    console.log(&quot;获取到的返回值:&quot;, result);&#125;getValue();</code></pre><p>注意：</p><ul><li><code>await</code> 只能在 <strong><code>async</code> 函数</strong> 中使用。</li><li><code>await</code> 会暂停当前 <code>async</code> 函数的执行，直到异步操作完成。</li></ul><ol start="3"><li><strong>回调函数</strong></li></ol><p>将一个回调函数作为参数传入异步函数，在异步操作完成后调用该回调函数并传入返回值。</p><p>示例代码</p><pre><code class="javascript">function asyncFunction(callback) &#123;    setTimeout(() =&gt; &#123;        const value = &quot;异步返回值&quot;;        callback(value); // 调用回调函数，传入返回值    &#125;, 1000);&#125;// 使用回调函数获取返回值asyncFunction((result) =&gt; &#123;    console.log(&quot;获取到的返回值:&quot;, result);&#125;);</code></pre><ol start="4"><li><strong>结合 <code>async/await</code> 和 <code>Promise</code> 的例子</strong></li></ol><p>当你调用一个异步函数，返回的是 <strong>Promise</strong>，你可以用 <code>async/await</code> 来等待它的完成。</p><p>示例代码</p><pre><code class="javascript">function fetchData() &#123;    return new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; resolve(&quot;返回数据成功&quot;), 1000);    &#125;);&#125;async function getData() &#123;    const result = await fetchData();    console.log(&quot;最终获取的数据:&quot;, result);&#125;getData();</code></pre><ol start="5"><li><strong>立即执行异步函数 (IIFE)</strong></li></ol><p>有时你需要在代码块内立即调用 <code>async</code> 函数，可以使用 **立即执行函数表达式 (IIFE)**。</p><p>示例代码</p><pre><code class="javascript">(async () =&gt; &#123;    const result = await asyncFunction();    console.log(&quot;立即执行异步函数的返回值:&quot;, result);&#125;)();</code></pre></blockquote><h4 id="删除历史记录"><a href="#删除历史记录" class="headerlink" title="删除历史记录"></a>删除历史记录</h4><p>使用 delate 方法删除历史记录：</p><pre><code class="js">const request = indexedDB.open(&quot;VditorHistoryDB&quot;, dbVersion);request.onsuccess = (event) =&gt; &#123;    const db = event.target.result;    const transaction = db.transaction(&quot;history&quot;, &quot;readwrite&quot;);    const store = transaction.objectStore(&quot;history&quot;);    const deleteRequest = store.delete(recordId); // 替换 recordId 为你要删除的记录的 ID    deleteRequest.onsuccess = () =&gt; &#123;        console.log(&quot;记录已删除&quot;);    &#125;;    deleteRequest.onerror = (event) =&gt; &#123;        console.error(&quot;删除记录失败&quot;, event.target.error);    &#125;;&#125;;</code></pre><p>2024&#x2F;12&#x2F;19</p><hr><h2 id="三、完成"><a href="#三、完成" class="headerlink" title="三、完成"></a>三、完成</h2><p>大概耗时十天时间，我们从无到有完成了这个脚本的编写。</p><p>事实上，我认为这次尝试，是利用 AI 进行学习的一种方式。</p><p>过去人们大部分情况下只能从前到后，一步步到达想要的结果，但是 AI 让我们可以从后向前，并且在这个过程中一点点弄清楚这个东西的原理，这一点是以往人所达不到的。</p><p>最后我希望我自己可以继续维护这个脚本，不断为其添加新的功能。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      从零基础开始编写的油猴脚本，一个可以应用于浏览器的笔记本脚本。轻量，方便，支持 Markdown 语法。高效的浏览器学习工具。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Web" scheme="http://ccr39.github.io/tags/Web/"/>
    
      <category term="脚本" scheme="http://ccr39.github.io/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Git入门（三）提交到远程库</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/git-3/"/>
    <id>http://ccr39.github.io/技术/git-3/</id>
    <published>2024-12-13T07:38:00.000Z</published>
    <updated>2024-12-13T08:01:45.682Z</updated>
    
    <content type="html"><![CDATA[<p>往期文章：<a href="https://ccr39.github.io/%E6%8A%80%E6%9C%AF/git-1/">Git 的入门（一）：Git 的基本概念以及 Git 命令行的使用</a>、<a href="https://ccr39.github.io/%E6%8A%80%E6%9C%AF/git-2/">Git 的入门（二）：Git 的常用命令 | CCR39のLazyNest</a></p><h3 id="1、在-Github-上创建一个远程仓库"><a href="#1、在-Github-上创建一个远程仓库" class="headerlink" title="1、在 Github 上创建一个远程仓库"></a>1、在 Github 上创建一个远程仓库</h3><p><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/new_dyn/4d11fd2fe4f0767644990c34b83a740c1865926893.png"></p><p>点击 <strong>New</strong> 创建，之后取个名字。拉到最下方直接创建。</p><h3 id="2、在本地关联到远程仓库"><a href="#2、在本地关联到远程仓库" class="headerlink" title="2、在本地关联到远程仓库"></a>2、在本地关联到远程仓库</h3><p>保证本地 git 已经配置好，在已经初始化的本地文件夹的命令台输入：</p><pre><code class="powershell">git remote add origin git@github.com:远程仓库目录.git</code></pre><p>这里的<strong>远程仓库目录</strong>就是<code>用户名/仓库名</code></p><p>例如：</p><pre><code class="powershell">git remote add origin git@github.com:ccr39/NicoNote.git</code></pre><h3 id="3、把本地仓库提交到远程仓库"><a href="#3、把本地仓库提交到远程仓库" class="headerlink" title="3、把本地仓库提交到远程仓库"></a>3、把本地仓库提交到远程仓库</h3><p>先把所有文件提交到本地库：</p><pre><code class="powershell">git add . git commit -m &quot;注释&quot;</code></pre><p>再提交到远程仓库：</p><pre><code class="powershell">git push -u origin 分支名</code></pre><p>默认分支一般为<code>master</code>或<code>main</code>。</p><p>上面的 origin 就是远程仓库的意思。</p><h3 id="4、其他指令"><a href="#4、其他指令" class="headerlink" title="4、其他指令"></a>4、其他指令</h3><ul><li>将远程仓库的文件拷贝到本地文件夹</li></ul><pre><code class="powershell">git clone 仓库地址</code></pre><ul><li>从远程获取最新版本到本地</li></ul><pre><code class="powershell">git fetch origin 分支名</code></pre><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      把本地仓库提交到 Github 上。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>只身陷入心理治疗骗局！！深扒“SCIO全科生物反馈测疗仪”与“心理AI智能检测”底裤。</title>
    <link href="http://ccr39.github.io/%E7%94%9F%E6%B4%BB/SCIO/"/>
    <id>http://ccr39.github.io/生活/SCIO/</id>
    <published>2024-12-13T07:14:00.000Z</published>
    <updated>2024-12-13T07:15:20.658Z</updated>
    
    <content type="html"><![CDATA[<p>转载于本人知乎：<a href="https://zhuanlan.zhihu.com/p/12090143389">只身陷入心理治疗骗局！！深扒“SCIO全科生物反馈测疗仪”与“心理AI智能检测”底裤。 - 知乎</a></p><h3 id="故事的开始："><a href="#故事的开始：" class="headerlink" title="故事的开始："></a><strong>故事的开始：</strong></h3><blockquote><p>本人去往医院作心理治疗，主治医生拿出一个小条，在”AI 心理治疗-情绪“上画上一个勾勾。我心想：AI 治疗？现在都这么高级了吗？随后便被告知要治疗780元的诊断费用。。。。算了，尝试高科技治病，能治好不嫌贵。开始治疗时，医生在我四肢和头部处绑上检测用的软环，在一旁躺下，接下来就开始不断点击电脑。由于没有任何感觉，我甚至不知道治疗在什么时候开始的，本人早上起的很早，于是直接睡下了。大概四十分钟后，大夫告诉说可以起来了，我还心想，这到底是发生了什么，完全没有感觉就完成治疗了。</p></blockquote><p><img src="https://pica.zhimg.com/v2-63458d27c5f20e09ecd4ef86286039a0_1440w.jpg" alt="img"></p><p>大概就长这个样子，旁边有个供躺着的沙发，另外软环用线连接着仪器</p><blockquote><p>等到打印报告时直接让我傻眼了：报告上赫然写着“SCIO 数字治疗”结果单底下不光列出了“情绪心理指数”、“第一次治疗记录”最逆天的是包括72项“情绪与心理反应性细项”，它明确的列出了72项有关心理的指标，并对每一项指标进行了定量化与说明。由于是在专业医院做的专业检测，我也没有多想什么，把报告给大夫看了看，大夫根据报告中的内容对我进行了诊断。</p></blockquote><p><img src="https://pic4.zhimg.com/v2-2f0261ae47ced350177bd89b3768efc5_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-3ac9f11224349859a80d0c22ca0331da_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/v2-c0e8c3fd168a1363f5c3266ee7a04eb6_1440w.jpg" alt="img"></p><p>诸如此类项目，每一个都有明确的指标</p><h3 id="揭穿”-AI智能检测-“的真像"><a href="#揭穿”-AI智能检测-“的真像" class="headerlink" title="揭穿” AI智能检测 “的真像"></a>揭穿” AI<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E6%99%BA%E8%83%BD%E6%A3%80%E6%B5%8B&zhida_source=entity">智能检测</a> “的真像</h3><p>等回到家我才意识到问题的不对：</p><ul><li>首先，无论是检测还是治疗，都需要一定介质来采集<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF&zhida_source=entity">生物信息</a>，之前<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E7%BB%8F%E9%A2%85%E7%A3%81&zhida_source=entity">经颅磁</a>利用的是磁场，而这个“AI治疗”只使用几个环，它是通过什么采集信息，还能保证信息如此精确。（既分类、又定量）</li><li>其次，在网络上搜索“AI治疗”出现的信息均为使用大预言模型进行治疗，这个“AI治疗”到底哪里用到AI了。</li><li>然后，大夫根据报告给出的治疗咨询疑似利用了<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E5%B7%B4%E7%BA%B3%E5%A7%86%E6%95%88%E5%BA%94&zhida_source=entity">巴纳姆效应</a>（Barnum effect），说白了就是得出的结论很笼统，<strong>类似算命师傅解卦</strong>。</li></ul><p>于是，我在网络上查询 SCIO 相关字样，但是<strong>几乎没有得到任何相关的信息</strong>。换用“SCIO生物反馈仪”作为关键词在中文互联网上搜索，终于查询到了知乎上的一篇文章，请先阅读该文章：</p><p><a href="https://zhuanlan.zhihu.com/p/25025862">号称不采一滴血就能检测上万种指标的“SCIO生物反馈仪”，到底是啥货？</a></p><p>除此之外，只有寥寥无几的几篇关于这个仪器的信息。</p><p>有趣的是，当我在知乎、抖音上输入SCIO生物反馈仪时，搜索框中的相关搜索选项中出现了：</p><p><strong>“SCIO生物反馈仪 智商税 ”“ SCIO生物反馈仪 有用吗”</strong>相关字样。（看来被坑的不止我一个）</p><p>总结上述文章与已知消息我们得到以下真相：</p><ul><li>首先，在官网上对 SCIO 全科生物反馈测疗仪的描述是：</li></ul><blockquote><p>依据量子物理学和<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E6%8B%93%E6%89%91%E5%AD%A6&zhida_source=entity">拓扑学</a>的原理，通过非侵入性的无痛、无副作用的电化学极谱分析和测量，通过计时电势分析法等运算方法，检测身体11000多项指标，从而获得早期风险提示，是一种集健康监测与干预调理为一体的具有国际先进水平的医疗器械，仪器具有极高的灵敏度，能检测到0.2µV极其微弱的人体生物能变化，从而精确的捕捉到任何早期疾病风险，提早预防。20多年来获得欧盟，美国，澳大利亚，加拿大，韩国等众多国家食药局的认证，为很多国际知名人士指定专项健康管理系统，2008年奥运会指定合作项目，为奥运冠军保驾护航。</p></blockquote><ul><li>事实上，这个 SCIO 全科生物反馈测疗仪，是由一个名为Willian C. Nelson的美国人发明的机器，最初发明该机器时<strong>涉及虚假宣传</strong> ，使其本人遭受逮捕，被迫逃往<strong>匈牙利（记住这个，后面要考）</strong>。之后由于FDA通过医疗器械调整法案，大大降低注册难度，SCIO 成功注册，但之后，<strong>有微软软件工程师在查看其后台数据库后，指出其检查结果是随机给出的</strong>。（关于详情信息及来源，在上述文章中有提到）</li></ul><p><img src="https://pica.zhimg.com/v2-6463c65f6b10bbc1870ea7c8004a0462_1440w.jpg" alt="img"></p><p>国外的版本</p><ul><li>而国内的 SCIO 全科生物反馈测疗仪，是在外国版本中发展而来，但是国内的炒作鬼才将其包装成了现在更加高大上的样子，并且卖出高价。</li><li>我们找到了这个机器的[注册号：国械注进20162093114](<a href="https://zhuanlan.zhihu.com/p/12090143389/%E3%80%82%E5%8F%91%E7%8E%B0%E8%AF%A5%E5%99%A8%E6%A2%B0%E6%9C%80%E5%88%9D%E5%BA%94%E8%AF%A5%E5%9C%A82016%E5%B9%B4%E6%B3%A8%E5%86%8C%EF%BC%8C%E8%80%8C%E5%9C%A82022%E5%B9%B4%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%89%B9%E5%87%86%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%BA%BA%E4%B8%BA**%E5%8C%88%E7%89%99%E5%88%A9%E6%9F%90%E5%85%AC%E5%8F%B8%E4%BA%BA%E5%91%98%EF%BC%8C%E5%8D%B0%E8%AF%81%E4%BA%86%E5%9B%BD%E5%86%85%E5%A4%96SCIO%E4%B8%BA%E5%90%8C%E6%BA%90%E3%80%82">https://zhuanlan.zhihu.com/p/12090143389/。发现该器械最初应该在2016年注册，而在2022年进行了批准。我们可以看到，注册人为**匈牙利某公司人员，印证了国内外SCIO为同源。</a>**</li></ul><p><img src="https://pic2.zhimg.com/v2-c33bfbf189a618a4080e99a0044e18bf_1440w.jpg" alt="img"></p><p>产品的注册信息，注册号：国械注进20162093114</p><ul><li>但事实上，这个在这之前这个产品还有另一个注册号：<a href="https://link.zhihu.com/?target=https://www.nmpa.gov.cn/datasearch/search-info.html?nmpa=aWQ9MjAyMDA0MTAyODQyOSZpdGVtSWQ9ZmY4MDgwODE4MzBiMTAzNTAxODM4ZDRhNWUzMjM1OWY=">国食药监械(进)字2012第2213148号</a>（产品最早在2012年引入，08年奥运会一事显然不合理）再变更信息中，代理人名称变更为<strong>北京瑞蜜达国际生物科技有限公司</strong>。这样，两者就基本可以对上来了。</li></ul><p><img src="https://pic3.zhimg.com/v2-94d2a9f0f3229192af034bd032886240_1440w.jpg" alt="img"></p><p>国食药监械(进)字2012第2213148号</p><h3 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h3><p>在查询资料过程中我们可以发现一个有意思的事情：那就是”国械注进20162093114“应该是16年九月份就发布了注册申请，而直到22年才再次被批准，这是为什么？</p><p>直到我看到，一个名为犀贝众齿联的公司（SCIO国内的新代理商）发布的文章：</p><p><a href="https://www.zhihu.com/question/23691436/answer/3033870276">SCiO这款产品真的有他们自己说的这么强大么？</a></p><p>里面提到：</p><blockquote><p>犀贝，作为一直以助力大健康行业的发展为理念，这次与山西省合作的「SCIO无创生物反馈人体检测」项目，就是<a href="https://zhida.zhihu.com/search?content_id=251440850&content_type=Article&match_order=1&q=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%8C%BB%E7%96%97&zhida_source=entity">人工智能与医疗</a>深度融合的一项。</p></blockquote><p>再结合我自己的经历才终于明白：合着是把好几年前的冷饭顺着AI的东风再炒起来，所以归根到底这个系统根本与AI毫无关系。而为了获批，这之中的利益关系我们又不得而知。</p><p>但是，仅仅是运用在心理治疗上也就没什么了，最令人害怕的事情是：本人再抖音上看到了癌症将患者使用该仪器的<a href="https://link.zhihu.com/?target=https://www.douyin.com/search/scio%E6%A3%80%E6%B5%8B%E7%9C%9F%E5%AE%9E%E5%90%97?aid=803dfb1a-31fa-4a96-bf6a-1c92baad9cd9&modal_id=7110487129683152136&type=general">视频</a>，深感痛心。</p><p>总的来说，本人算是交了次智商税。而和我去同一门诊的人不在少数。很难想象这种在网上都很难查到资料的器械被我碰到了。。。写这篇文章只希望能为中文互联网增加一点资料，至少不是什么都查不到了。。。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      一次悲惨而值得反思的教训。
    
    </summary>
    
      <category term="生活" scheme="http://ccr39.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂谈" scheme="http://ccr39.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Restart:My Blog</title>
    <link href="http://ccr39.github.io/%E7%94%9F%E6%B4%BB/2024-12-13/"/>
    <id>http://ccr39.github.io/生活/2024-12-13/</id>
    <published>2024-12-13T06:19:00.000Z</published>
    <updated>2024-12-13T07:11:02.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有关为什么很久没有维护博客："><a href="#有关为什么很久没有维护博客：" class="headerlink" title="有关为什么很久没有维护博客："></a>有关为什么很久没有维护博客：</h3><ol><li>学业需要，没有时间来进行维护。</li><li>域名过期，续费域名需要一定费用。</li><li>原来的本地环境丢失，需要重新搭建环境。</li><li>懒。</li></ol><h3 id="有关博客有那些功能失修："><a href="#有关博客有那些功能失修：" class="headerlink" title="有关博客有那些功能失修："></a>有关博客有那些功能失修：</h3><ol><li>域名无法使用，因此沿用 Github 静态代理的网址：<a href="https://ccr39.github.io/">https://ccr39.github.io/</a></li><li>部分图片失效。</li><li>部分内容或资源失效。</li><li>静态代理网络原因可能导致卡顿或部分时间上不去。</li><li>听歌系统有时抽风显示不出来。</li></ol><h3 id="有关博客的维修："><a href="#有关博客的维修：" class="headerlink" title="有关博客的维修："></a>有关博客的维修：</h3><ol><li>使用科学上网可以得到最佳的体验。</li><li>评论系统由于部署在 vercel 上，而 vercel 被墙，因此重新部署至 netlify 目前已经可以正常使用。</li><li>重新替代了部分图片。</li><li>目前大部分功能已经恢复。</li></ol><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      重新使用我的博客
    
    </summary>
    
      <category term="生活" scheme="http://ccr39.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="杂谈" scheme="http://ccr39.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>图床的使用与推荐</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/picbed/"/>
    <id>http://ccr39.github.io/技术/picbed/</id>
    <published>2023-01-20T12:21:32.000Z</published>
    <updated>2024-12-13T05:57:34.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、了解图床"><a href="#一、了解图床" class="headerlink" title="一、了解图床"></a>一、了解图床</h2><p>引用百度的话：</p><blockquote><p>图床就是专门用来存放图片，同时允许你把图片对外连接的网上空间。</p></blockquote><p>简单来说，我们在网上看到的所有的信息都是要储存在服务器里面的，那么允许我们上传图片，并且生成网上链接供给他人观看此图片的空间，就叫做图床。</p><p>图床分为很多种，你可以把图片放在自己的服务器&#x2F;云服务器中，并生成链接。也可以使用他人提供的服务器生成的链接，服务器的不同也会造成图片的访问速度不同，同时可能还存在一些大小限制。</p><h2 id="二、使用图床"><a href="#二、使用图床" class="headerlink" title="二、使用图床"></a>二、使用图床</h2><p>图床有什么用？要知道，有的时候部分网页时不支持上传图片的，如某些论坛，他们不支持图片上传，因此你需要预先将图片上传到其他服务器，并生成图床链接。</p><p>还有的时候，如你在写 web 脚本，博客，此时的图片信息一般也使用图床。</p><p>下面我将演示图片的上传，以及生成相应链接。</p><h3 id="1、首先，我们打开提供图片上传的网站（图床网站，这里以-sm-ms-为例）"><a href="#1、首先，我们打开提供图片上传的网站（图床网站，这里以-sm-ms-为例）" class="headerlink" title="1、首先，我们打开提供图片上传的网站（图床网站，这里以 sm.ms 为例）"></a>1、首先，我们打开提供图片上传的网站（图床网站，这里以 <a href="https://smms.app/">sm.ms</a> 为例）</h3><p><img src="https://i0.hdslb.com/bfs/album/d12491a471053df6cc7ca57a98a747be107b091d.png" alt="image-20230120165527526"></p><h3 id="2、按照提示注册账号"><a href="#2、按照提示注册账号" class="headerlink" title="2、按照提示注册账号"></a>2、按照提示注册账号</h3><h3 id="3、上传图片"><a href="#3、上传图片" class="headerlink" title="3、上传图片"></a>3、上传图片</h3><p>直接将图片拖动到页面中，或预览文件，并选择图片。</p><p><img src="https://i0.hdslb.com/bfs/album/cbd56adcb56d59e7cca345b8e2a9b481cb311e81.png" alt="屏幕截图_20230120_165758"></p><p>接下来点击上传。</p><p><img src="https://i0.hdslb.com/bfs/album/fa22f8e4104ff39a5ed005aa614e065793a9eac0.png" alt="image-20230120170016531"></p><h3 id="4、获取图片链接"><a href="#4、获取图片链接" class="headerlink" title="4、获取图片链接"></a>4、获取图片链接</h3><p>上传成功后在下方点击复制链接即可。</p><p><img src="https://i0.hdslb.com/bfs/album/ab4fdb30d62e4f7f5ded83070f0d925ec92ee782.png" alt="image-20230120170416528"></p><p>这里大家如果不明白复制哪一个，就先点击上面的 Image URL 再复制出现的链接即可。</p><p>这只是 <a href="https://smms.app/">sm.ms</a> 的用法，其他的图床网站均类似，最后均选择复制<strong>图片URL</strong>。</p><h2 id="三、图床网站的推荐"><a href="#三、图床网站的推荐" class="headerlink" title="三、图床网站的推荐"></a>三、图床网站的推荐</h2><p>注意，这里只涉及提供图床网站的推荐，并不包含自建图床，对于图床的一些进阶使用，我会再写一篇文章进行叙述。</p><p>在上面提到过图片的加载速度与图床有关，因此使用一个好的图床实分重要，同时，你上传的的图片有可能被删除，图床网站也有可能跑路，因此图床的稳定性也很重要。</p><p>这里提醒大家：<strong>不要上传违法照片</strong></p><p>下面我推荐两个网站：</p><h3 id="1、-sm-ms"><a href="#1、-sm-ms" class="headerlink" title="1、 sm.ms"></a>1、 <a href="https://smms.app/">sm.ms</a></h3><p>这是上面提到的网站，服务器在国外，之前被国内墙过，被墙的图床生成的图片在国内也无法显示。</p><p>其使用了新网站<a href="https://smms.app/">Image Upload - SM.MS - Simple Free Image Hosting (smms.app)</a>，新网站解决了被墙的问题。</p><p>新用户注册免费使用 5GB 的空间，每张图片最大 5MB ，每次最多上传十张图片。</p><p>由于在国外，其图片加载速度一般，因此如果加载大量图片不建议使用，但是十分稳定，在少量使用时成为首选。</p><p>如果想要追求更高速度可以继续阅读下文第四章。</p><h3 id="2、路过图床"><a href="#2、路过图床" class="headerlink" title="2、路过图床"></a>2、<a href="https://imgse.com/">路过图床</a></h3><p>这是国内的网站，最大单张支持10 MB，在国内加载速度良好。</p><p>但是路过图床<strong>不允许上传二次元图片</strong>，并且会对上传的违法图片进行删除。</p><h3 id="3、图床-imgloc-com"><a href="#3、图床-imgloc-com" class="headerlink" title="3、图床 imgloc.com"></a>3、<a href="https://imgloc.com/">图床 imgloc.com</a></h3><p>最大 6 MB 图片大小，在国内的速度同样良好。</p><p>相比于路过图床，支持上传二次元图片，但是也会对违法图片进行删除。</p><h2 id="四、使用-wsrv-nl-对图片访问加速"><a href="#四、使用-wsrv-nl-对图片访问加速" class="headerlink" title="四、使用 wsrv.nl 对图片访问加速"></a>四、使用 wsrv.nl 对图片访问加速</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>werv.nl 是一个十分强大的提供图像缓存和调整大小服务的工具。</p><p>他会先把图片进行缓存，同时你可以使用它对图片进行编辑与操作。</p><p>因为他的CDN由<a href="https://www.cloudflare.com/">Cloudflare</a>提供，而Cloudflare会对全球访问进行加速，因此我们可以用 werv.nl 对图片进行缓存，从而进行加速的效果。</p><p>利用这一方法，我们可以解决图床被墙，访问慢，甚至防盗链等问题。</p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><p>详细使用已经编辑图像请阅读<a href="https://images.weserv.nl/docs/">官方文档</a>，我们只介绍缓存图片的方法。</p><p>在原来的图片链接前加上：</p><pre><code> https://images.weserv.nl/?url=</code></pre><p>即可完成缓存，接下来只要使用组合成的新链接即可。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      了解图床以及使用图床
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Git 的入门（二）：Git 的常用命令</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/git-2/"/>
    <id>http://ccr39.github.io/技术/git-2/</id>
    <published>2023-01-20T08:23:34.000Z</published>
    <updated>2024-12-13T06:07:22.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设置用户签名"><a href="#一、设置用户签名" class="headerlink" title="一、设置用户签名"></a>一、设置用户签名</h2><p>当我们使用 Git 前，首先要设置自己的用户签名。</p><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>在任意控制台下输入：</p><pre><code class="git">git config --global user.name 用户名git config --global user.email 邮箱</code></pre><p>注意，在此处设置的邮箱并不一定为真实邮箱， Git 也并不会验证其真实性。</p><p>同时，此邮箱与将来使用的 GitHub 没有关系。</p><p><strong>但是最好用自己创建 GitHub 的邮箱，不然提交代码没有小绿点！</strong></p><h3 id="2、用户签名所在位置"><a href="#2、用户签名所在位置" class="headerlink" title="2、用户签名所在位置"></a>2、用户签名所在位置</h3><p>在 Git 设置的用户签名会保存在<code>C:\Users\你当前使用的用户\.gitconfig</code></p><p>当我们尝试打开此文件可以看到</p><pre><code class=".gitconfig">[user]    name = 用户名    email = 邮箱</code></pre><h2 id="二、初始化本地库"><a href="#二、初始化本地库" class="headerlink" title="二、初始化本地库"></a>二、初始化本地库</h2><h3 id="1、基本语法-1"><a href="#1、基本语法-1" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><pre><code class="git">git init</code></pre><h3 id="2、具体用法"><a href="#2、具体用法" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>在我们的工作区文件夹下打开 Git，并执行代码进行初始化本地库。</p><p>如果文件夹没有进行初始化，那么 Git 将没有权限修改文件。</p><p>执行完毕后，Git 将在文件夹下生成名为<code>.git</code>的文件夹（如果没有，是因为此文件夹被系统自动隐藏，请开启查看隐藏的文件）</p><h2 id="三、将文件添加-x2F-删除到暂存区"><a href="#三、将文件添加-x2F-删除到暂存区" class="headerlink" title="三、将文件添加&#x2F;删除到暂存区"></a>三、将文件添加&#x2F;删除到暂存区</h2><h3 id="1、基本语法-2"><a href="#1、基本语法-2" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>添加命令：</p><pre><code class="git">git add .git add 文件名</code></pre><p>删除命令：</p><pre><code class="git">git rm --cached 文件名rm .git/index</code></pre><h3 id="2、具体用法-1"><a href="#2、具体用法-1" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>添加命令：将工作区的文件添加到暂存区，其中第一行指令为将工作区所有文件添加到暂存区，第二行指令为将指定文件添加到暂存区。</p><p>删除命令：第一行为将某文件从暂存区移除，暂存区实质是.git目录下的index文件，只要将此文件删除，那么就可以认为暂存区被清空（即第二行代码）。</p><h2 id="四、提交到本地库"><a href="#四、提交到本地库" class="headerlink" title="四、提交到本地库"></a>四、提交到本地库</h2><h3 id="1、基本语法-3"><a href="#1、基本语法-3" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>提交暂存区到本地仓库中:</p><pre><code class="git">git commit -m [message]</code></pre><p>[message] 可以是一些备注信息。</p><p>提交暂存区的指定文件到仓库区：</p><pre><code class="git">$ git commit [file1] [file2] ... -m [message]</code></pre><p><strong>-a</strong> 参数设置修改文件后不需要执行 git add 命令，直接来提交</p><pre><code class="git">$ git commit -a</code></pre><h3 id="2、具体用法-2"><a href="#2、具体用法-2" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>使用提交命令提交到本地库中的文件不能再次删除。</p><h2 id="五、查看本地库状态"><a href="#五、查看本地库状态" class="headerlink" title="五、查看本地库状态"></a>五、查看本地库状态</h2><h3 id="1、基本语法-4"><a href="#1、基本语法-4" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><pre><code class="git">git status</code></pre><h3 id="2、具体用法-3"><a href="#2、具体用法-3" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>当工作区文件没有在暂存区找到时，会提示：</p><pre><code class="git">$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        new3.txt</code></pre><p>当我们使用命令将文件添加到暂存区，提示：</p><pre><code class="git">$ git statusOn branch masterChanges to be committed:  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        new file:   new3.txt</code></pre><p>代表我们还未将文件提交本地库，再次执行提交本地库的命令，会提示：</p><pre><code class="git">$ git statusOn branch masternothing to commit, working tree clean</code></pre><p>表明文件已经全部提交到本地库。</p><h2 id="六、查看历史版本"><a href="#六、查看历史版本" class="headerlink" title="六、查看历史版本"></a>六、查看历史版本</h2><h3 id="1、基本语法-5"><a href="#1、基本语法-5" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><pre><code class="git">git reflog查看精简版本信息git log查看版本信息</code></pre><h3 id="2、具体用法-4"><a href="#2、具体用法-4" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>使用<code>git reflog</code>可以查看本地库中的各个版本号前七位，以及该版本的备注信息，以及当前版本指向的本地库中的版本。</p><p>使用<code>git log</code>咳哟看到本地库中各版本完整的版本号，提交者及邮箱，提交日期以及备注信息。</p><p>如:</p><pre><code class="git">$ git logcommit c1c925dffc5b57bdb82b22d0d9ae18c8d5cf141f (HEAD -&gt; master)Author: ccr39 &lt;1632145835@qq.com&gt;Date:   Fri Jan 20 15:44:41 2023 +0800    测试版本</code></pre><p>commit 后的就是版本号。</p><h2 id="七、进行版本穿梭"><a href="#七、进行版本穿梭" class="headerlink" title="七、进行版本穿梭"></a>七、进行版本穿梭</h2><h3 id="1、基本语法-6"><a href="#1、基本语法-6" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><pre><code class="git">git reset --hard 版本号/版本号前七位</code></pre><h3 id="2、具体用法-5"><a href="#2、具体用法-5" class="headerlink" title="2、具体用法"></a>2、具体用法</h3><p>使用版本穿梭命令进行版本穿梭。我们可以再次使用<code>git reflog</code>查看版本信息。</p><p>观察到新生成了一个日志信息，以及当前指针已经指向穿梭到的版本号。</p><pre><code class="git">$ git reflogc845da5 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to c845da5新生成的版本信息c1c925d HEAD@&#123;1&#125;: commit: 测试版本4738829 HEAD@&#123;2&#125;: commit: secondc845da5 (HEAD -&gt; master) HEAD@&#123;3&#125;: commit (initial): first当前指针指向的版本</code></pre><p>我们可以再次验证本地库的文件状态，发现本地库中的文件已经回到原来版本的状态。</p><p>实际上，指针先指向了 master 分支，再指向了我们的相应版本。</p><p>我们可以在<code>.\.git\HEAD</code>看到：</p><pre><code class="yaml">ref: refs/heads/master</code></pre><p>表明指针在指向 master。</p><p>再次打开<code>.\.git\refs\heads\master</code>，可以看到，在 master 文件中正保存了当前的版本号。表明 master 版本指向了我们当前的版本。</p><p>实际上，Git 切换版本的实质是移动 HEAD 指针。</p><p>在刚刚的案例中：HEAD -&gt; master（分支）-&gt; 版本。通过移动指针指向不同的分支与版本，即可完成版本控制。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      从保存到暂存区，到提交到本地库。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Git 的入门（一）：Git 的基本概念以及 Git 命令行的使用</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/git-1/"/>
    <id>http://ccr39.github.io/技术/git-1/</id>
    <published>2023-01-09T02:35:27.000Z</published>
    <updated>2024-12-13T06:07:12.809Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是 Linux 之父 Linus 为维护 Linux 社区所开发的一款<strong>分布式</strong>版本控制工具。</p><p>学会使用 Git 能够为我们带来很大的帮助，接下来我就来简单带大家了解 Git 这个工具。</p><h2 id="一、版本控制工具"><a href="#一、版本控制工具" class="headerlink" title="一、版本控制工具"></a>一、版本控制工具</h2><p>刚才我们说过：“Git 是一款分布式代码版本控制工具” 因此，让我们先来了解代码版本控制工具是什么。</p><p>我们想象以下场景：</p><blockquote><p>如果你在写一篇文章，在写完后你又经过了多次的修改，此时我们就习惯于把每个版本都复制下来，保存副本，这样当我们文章出现问题时，就可以对比以前的版本查找问题所在。</p></blockquote><p>在上面的的情景中，我们对文章不同版本的拷贝就可以看作是对这篇文章进行了版本控制，但是大家也能轻而易举的发现这样的问题所在，也就是这种版本控制的方法过于繁琐，完全不优雅，而且在实际中，协同工作十分常见，这时就需要大家同时对一个项目进行版本控制。</p><p>因此，版本控制工具就孕育而生。</p><h3 id="集中式版本控制工具"><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h3><p>在对我们的主人公 Git 所属于的分布式版本控制工具介绍之前，请先让我们了解集中式版本控制工具（例如 CVS 及 SVN）。</p><p>我们来看看集中式的版本控制工具是如何进行协同工作的版本控制的：</p><p>集中式的版本控制系统，所有的版本库是放在中央服务器中的，也就是说我们每一次的修改上传都是保存在中央服务器中的。中央服务器就是个大仓库，大家把产品都堆里面，每一次需要改进和完善的时候，需要去仓库里面把文件给提出来，然后再操作。</p><p><img src="https://i0.hdslb.com/bfs/album/e0c6ede8a6d15bbdeb078de90700b0cc22013d3e.png" alt="image-20230109124132301"></p><p>这种做法也存在弊端，如：当中央服务器，或网络出现故障时，大家就无法再对我们的代码进行版本控制，因此导致他们在故障的这段时间，谁都无法继续进行工作。</p><h3 id="分布式版本控制工具"><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h3><p>为了解决集中式版本控制工具的种种弊端，分布式版本控制工具孕育而生。所谓分布，就是把版本库整个克隆到本地，让每台计算机上都还有一个完整的版本库。这样，即使在断网的环境下，我们也可以进行工作。</p><p>这时，如果我们想进行协同工作时，仅需要把最新的版本库共享给对方就能保证每个人的版本保持最新。</p><p><img src="https://i0.hdslb.com/bfs/album/4631b298c16ebf76189710151ac5f105669ccc0d.png" alt="image-20230109125015133"></p><p>但是这里面有个问题，就是一个团队很大的情况下，大家都去修改，到底找谁同步版本库，不乱套了嘛。而且，大的开发项目也不是简单的两台计算机之间的版本互推就可以得到完整的版本库的。所以，分布式版本控制系统中通常也会有一台充当“中央服务器”的计算机，被称为远程库（如：GitHub、码云）。</p><p>读到这，您可能觉得，又绕回到集中式版本管理系统了。但其实，两者间存在着本质区别，即集中式版本工具必须在中央服务器内才能进行版本控制，而分布式版本控制工具不然。而且，分布式版本控制依靠的远程库，一般来说几乎不可能出现故障。</p><h2 id="二、Git-的基本原理"><a href="#二、Git-的基本原理" class="headerlink" title="二、Git 的基本原理"></a>二、Git 的基本原理</h2><p><img src="https://i0.hdslb.com/bfs/album/c50d754447372e442ad49ad0b0a61a68eb051ffd.png" alt="img"></p><p>Git 的使用流程是：<strong>工作区&gt;&gt;暂存区&gt;&gt;本地仓库&gt;&gt;远程仓库</strong></p><ul><li><p><strong>工作区：</strong>即我们在电脑里储存项目的目录。</p></li><li><p><strong>暂存区：</strong>准备进行版本保存的文件列表。</p></li><li><p><strong>本地仓库：</strong>在本地保存的版本控制后的文件列表。</p></li><li><p><strong>远程仓库：</strong>基于网络服务器的远程代码仓库（代码托管平台）。</p><ol><li><p>局域网中的远程仓库</p><p>GitLab：在局域网（如：校园网）中搭建的远程库。</p></li><li><p>互联网中的远程仓库</p><p>GitHub：Git 官方的搭建远程仓库。</p><p>Gitee：国内版的 GitHub。</p></li></ol></li></ul><h2 id="三、Git-的安装"><a href="#三、Git-的安装" class="headerlink" title="三、Git 的安装"></a>三、Git 的安装</h2><p>进入 <a href="https://git-scm.com/download">Git 官网</a>，根据不同操作系统进行下载。（建议下载最新版）</p><p>安装选项在这里进行跳过，我的建议是：如果你不知道选项对应的是什么意思请直接选择使用默认设置。</p><p>详细的安装选项解释视频参考：<a href="https://www.bilibili.com/video/BV1vy4y1s7k6?p=7&vd_source=0cf100f40d6e892f3c398dd257aaeb68">尚硅谷 Git 安装和客户端的使用_哔哩哔哩</a></p><h2 id="四、Git-命令行的基本使用"><a href="#四、Git-命令行的基本使用" class="headerlink" title="四、Git 命令行的基本使用"></a>四、Git 命令行的基本使用</h2><p>在完成安装 Git 后，在任意文件夹内右键，点击 Git Bash Here 以打开命令行。</p><p><img src="https://i0.hdslb.com/bfs/album/4ca129e56000422d923118bdda1173b02be7afbe.png" alt="image-20230109154340649"></p><p><img src="https://i0.hdslb.com/bfs/album/b14f18816f623e1c07e86ff5b6bb9adf0d8f94e7.png" alt="image-20230109160102709"></p><p>进入到 Git 的命令行，由于 Git 与 Linux 是创作者是以为，所以，Git 支持几乎所有的 Linux 的指令，下面我简单列举常用的 Linux 指令。</p><table><thead><tr><th align="center">指令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">cd 路径</td><td align="center">进入对应路径，支持输入相对路径</td></tr><tr><td align="center">ls</td><td align="center">输出当前目录下的所有文件</td></tr><tr><td align="center">touch 文件名</td><td align="center">在当前目录创建文件</td></tr><tr><td align="center">cat 文件名</td><td align="center">显示当前目录中的文件的内容</td></tr><tr><td align="center">vim 文件名</td><td align="center">使用 <a href="https://ccr39.github.io/%E6%8A%80%E6%9C%AF/vim/">vim</a> 对当前目录下的文件进行编辑</td></tr><tr><td align="center">cp 文件1 文件2</td><td align="center">创建名为文件2的文件1副本</td></tr><tr><td align="center">rm 文件名</td><td align="center">删除文件</td></tr><tr><td align="center">mkdir 文件夹名</td><td align="center">创建文件夹</td></tr></tbody></table><p>接下来介绍在 Git 命令行中的复制粘贴快捷按键</p><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl + Insert</td><td align="center">复制</td></tr><tr><td align="center">ShIft + Insert</td><td align="center">粘贴</td></tr></tbody></table><p>如果你不习惯使用此指令，可以使用以下方法把复制&#x2F;粘贴的快捷键改为<code>Ctrl+Shift+C/V</code></p><p>首先打开<code>Git Bash</code>界面，右键单击标题栏，可以看到<code>option...</code>这个选项，点进去（如下图）。在<code>keys</code>标签下面的<code>ShortCuts</code>中，第一个复选框前面的对勾去掉并点击<code>Apply</code>+<code>Save</code>，即可不使用<code>Ctrl/Shift+Insert</code>复制粘贴了，之后勾选 <code>Ctrl+Shift+letter shortCuts</code>  ，就可以使用<code>Bash</code>终端常用的复制粘贴快捷键<code>Ctrl+Shift+C/V</code>。</p><p><img src="https://i0.hdslb.com/bfs/album/e8aa3d2b01862ead318fe89ea2ce43ec53198052.png" alt="image-20230109163129075"></p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',  ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      Git 是 Linux 之父 Linus 为维护 Linux 社区所开发的一款分布式代码版本控制工具。学会使用 Git 能够为我们带来很大的帮助，接下来我就来简单带大家了解 Git 这个工具。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Galgame】【PC/安卓直装】亚托莉—我挚爱的时光／ATRI -MY DEAR MOMENTS</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/Gal-Atri/"/>
    <id>http://ccr39.github.io/资源/Gal-Atri/</id>
    <published>2023-01-08T07:59:33.000Z</published>
    <updated>2024-12-13T05:56:24.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h3><p><strong>《ATRI -My Dear Moments-》</strong>是由 <a href="https://zh.moegirl.org.cn/ANIPLEX.EXE">ANIPLEX.EXE</a> 和 <a href="https://zh.moegirl.org.cn/Frontwing">Frontwing</a>、<a href="https://zh.moegirl.org.cn/%E6%9E%95">枕社(The pillow)</a> 共同制作，并由 <a href="https://zh.moegirl.org.cn/ANIPLEX.EXE">ANIPLEX.EXE</a> 发行的一部<a href="https://zh.moegirl.org.cn/%E8%A7%86%E8%A7%89%E5%B0%8F%E8%AF%B4">视觉小说</a>游戏。</p><h3 id="二、剧情介绍"><a href="#二、剧情介绍" class="headerlink" title="二、剧情介绍"></a>二、剧情介绍</h3><p>在不远的未来，海平面原因不明地急速上升，导致了地表多数都沉入海中。</p><p>小时候因为事故而失去一条腿的少年・斑鸠夏生，厌倦了都市的生活，移居到了海边的乡村小镇。曾经身为海洋地质学家的祖母留给他的、就只有船、潜水艇还有债务。<br>夏生为了取回“失去的未来”，与迷之讨债人凯瑟琳一起，潜海前往据说保存着祖母遗产的海底仓库。<br>在那里，他遇到了一位沉睡在如同棺材一般装置中不可思议的少女“亚托莉”。她是一位构造精密到与人类别无二致，而又丰富感情的机器人。<br>从海底被打捞起来的亚托莉如是说到。<br>“我想完成主人留给我的最后的命令。在此之前，我会成为夏生先生的腿！”<br>在一个逐渐沉入海中的平和小镇，少年和机器人少女的难忘夏日就这么开始了。</p><h3 id="三、游戏CG"><a href="#三、游戏CG" class="headerlink" title="三、游戏CG"></a>三、游戏CG</h3><p><img src="https://i0.hdslb.com/bfs/article/33923a15f1de4cf8c2f892325d98667ea1cf82e0.png" alt="b1ec39cad856762cfbb48eacf91c3b08d3414f4429aa2e37da681de0c7d8477f4a93311cd2cc4aa293bf490f6aea3a06 (690×517) (weiyun.com)"></p><p><img src="https://i0.hdslb.com/bfs/article/cc3ef2d6227f7394767afd9c5f0dd854b6a5fa8d.png" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/b140aa153ea244eef69cd17a5fc4fe2387db6090.png" alt="7d889a7e90677f3211c81274bf4d20f7afdd9f0ff788197b9c2970cdc603050b61d4b7f17deeff8cb0174cd7ce36d59f (772×505) (weiyun.com)"></p><h3 id="四、游戏攻略（谨慎观看）"><a href="#四、游戏攻略（谨慎观看）" class="headerlink" title="四、游戏攻略（谨慎观看）"></a>四、游戏攻略（谨慎观看）</h3><p>游戏共有三个选择支，分别为：</p><p>　　「成为你的右腿！」一章，第一次带阿托莉去市场时，凯瑟琳要求让阿托莉跟着她(把亚托莉交出去 \ 亚托莉先放我这)。</p><p>　　「日志」一章，晚上从学校返回船上时选择 是否对亚托莉动手动脚 (静静地看着她 \ 吻她)。</p><p>　　「被占据的学校」一章，从船上赶去学校时，选择(捡起鞋子 \ 放着不管)。</p><p>　　三个选择支分别选 「 亚托莉先放我这」「 吻她」「 捡起鞋子」 可达成HE。</p><p>　　任一选择支选错即为BE (BE结局很短)。</p><p>　　HE与BE均达成后解锁TE。</p><h3 id="五、资源分享"><a href="#五、资源分享" class="headerlink" title="五、资源分享"></a>五、资源分享</h3><p><font color=red>请先观看：</font><a href="https://ccr39.github.io/%E8%B5%84%E6%BA%90/galgame/">【索引】下载 Galgame 资源须知 </a></p><p>请直接点击<strong>代码框右上角的图标</strong>进行复制，复制后的文本如果带有：</p><pre><code>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者: ccr39链接：ccr39.love来源：CCR39のLazyNest</code></pre><p><strong>请先将这段文字删去</strong>，仅保留剩下的文字。</p><p>解压密码已经<strong>在文件名</strong>中标出，但解压密码<strong>不包含文件后缀</strong>，如<code>.rar</code> <code>.zip</code>，等。</p><p><strong>PC</strong> 秒传链接：</p><pre><code>dd0869c481c2f5bf64f948911bf31ab0#3795797161#ATRI-PC密码 穹妹的黑兔布偶.rar</code></pre><p><strong>安卓直装</strong> 秒传链接：</p><pre><code>5706f609b6b91861f2ac2c1333379836#996952426#亚托莉—我挚爱的时光.apk</code></pre><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      Atri 资源分享及攻略
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Galgame" scheme="http://ccr39.github.io/tags/Galgame/"/>
    
      <category term="PC" scheme="http://ccr39.github.io/tags/PC/"/>
    
      <category term="安卓直装" scheme="http://ccr39.github.io/tags/%E5%AE%89%E5%8D%93%E7%9B%B4%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>【Galgame】【PC/KRKR】纸上魔法使</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/Gal-zsmfs/"/>
    <id>http://ccr39.github.io/资源/Gal-zsmfs/</id>
    <published>2023-01-08T07:45:22.000Z</published>
    <updated>2024-12-13T05:56:40.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h3><p><strong>《纸上的魔法使》</strong>（日语：<strong>紙の上の魔法使い</strong>）是由<a href="https://zh.moegirl.org.cn/%E3%82%A6%E3%82%B0%E3%82%A4%E3%82%B9%E3%82%AB%E3%82%B0%E3%83%A9">ウグイスカグラ</a>开发，并于2014年12月19日发售的一部<a href="https://zh.moegirl.org.cn/Galgame">GalGame</a>，也是该社的处女作。该作由<a href="https://zh.moegirl.org.cn/index.php?title=%E3%83%AB%E3%82%AF%E3%83%AB&action=edit&redlink=1">ルクル</a>负责剧本，<a href="https://zh.moegirl.org.cn/%E6%A1%90%E5%8F%B6(%E7%94%BB%E5%B8%88)">桐葉</a>负责原画，讲述了一个略带奇幻色彩的恋爱故事。</p><h3 id="二、剧情介绍"><a href="#二、剧情介绍" class="headerlink" title="二、剧情介绍"></a>二、剧情介绍</h3><p>在某个岛上有一座规模略小的图书馆。<br>这座图书馆是专门为了某个少女而建造的，游行寺家的私人图书馆。<br>这座图书馆里有很多的罕见的书物，<br>如果是书虫的话，那就绝对不会存在比这里还要爱不释手的地方。<br>而，在这般首屈一指的私人图书馆里，住着几位出众且愉快的住人。</p><p>热爱图书的尼特少女·游行寺夜子。<br>毒舌，冷淡的妹妹·月社妃。<br>借住于图书馆的天然少女·伏见理央。<br>还有一位被这背后的秘密而吸引过来的侦探少女·日向彼方。</p><p>他们就宛如被什么而引导着一样，互相邂逅——<br>随后又以“喜爱书”这一点为契机，开始了属于他们的青春。<br>一开始的图书馆虽然寂寞单调，可自主人公一行人住进来之后这座图书馆就变得渐渐热闹了起来。<br>在不知不觉中——他们之间的关系变的亲密起来，达到了所谓青梅竹马的程度。</p><p>时光飞逝，2年后。<br>因家庭原因，主人公离开了这座岛屿。而这次，主人公久违的回到了那座图书馆。</p><p>与6年前相同这里还和以前一样，无论是图书馆还是亲爱的青梅竹马们都没有发生太大的变化。<br>可是，那在6年前未曾得知的“图书馆的秘密”这次却等待着主人公去揭晓它。</p><p>「——出现在书中之事，会在现世中再现。无论那是何等荒谬之事」「——出现在书中之事，会在现世中再现。无论那是何等荒谬之事」</p><p>如果是酸酸甜甜的恋爱系小说的话，那就会发生宛如飘渺的爱情罗曼史。<br>又假如那是惊讶重重的幻想系小说的话，到了明天就会有吸血鬼出现在你的面前。<br>而碰到了略惊悚的恐怖系物语的话，你的身后就会有幽灵在向你招手。</p><p>「这就是所谓的「这就是所谓的“魔法之书”“魔法之书”」」</p><p>这是一个被小清新的青春与苦闷焦躁的感情所动摇的，某个小小图书馆的物语……</p><p>游行寺夜子的逞强，<br>月社妃的可爱，<br>伏见理央的坚强，<br>日向彼方的耀眼感……<br>准备好——来一场你与“书”的恋爱吧。</p><h3 id="三、游戏CG"><a href="#三、游戏CG" class="headerlink" title="三、游戏CG"></a>三、游戏CG</h3><p><img src="https://i0.hdslb.com/bfs/album/7efdbd462931bbbc5a3a54a7d751fda4be2e11ce.jpg" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/album/03977a6b8bd8c4b9d1f782bab1d51ad37000716e.jpg" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/album/b8e5f3973802aeb4e226fee143d32cb49a87026e.jpg"></p><p><img src="https://i0.hdslb.com/bfs/article/58d29a8e7f127af2866be6ade9e2e190695b6a4c.jpg"></p><h3 id="四、游戏攻略"><a href="#四、游戏攻略" class="headerlink" title="四、游戏攻略"></a>四、游戏攻略</h3><p><strong>注：全部角色（克丽索贝莉露？）攻略完毕后才能激活预约特典补丁。</strong></p><p>游行寺夜子<br>◆SAVE01<br>对钟爱朋友的，极致的友谊<br>◆SAVE02<br>可最讨厌你<br>◆SAVE03<br>为了夜子，返还撕掉的书页<br>夜子 END</p><p>伏见理央<br>◆SAVE01开始<br>对钟爱少女的，极致的爱意<br>理央 END</p><p>月社妃<br>◆SAVE02开始<br>可最喜欢你<br>妃 END</p><p>克丽索贝莉露<br>◆SAVE03开始<br>为了自己，阅读撕掉的书页<br>◆SAVE04<br>不撕毁魔法之书<br>克丽索贝莉露 END</p><p>◆SAVE04开始<br>撕毁魔法之书<br>普通 END（彼方）</p><h3 id="五、资源分享"><a href="#五、资源分享" class="headerlink" title="五、资源分享"></a>五、资源分享</h3><p><font color=red>请先观看：</font><a href="https://ccr39.github.io/%E8%B5%84%E6%BA%90/galgame/">【索引】下载 Galgame 资源须知 </a></p><p>请直接点击<strong>代码框右上角的图标</strong>进行复制，复制后的文本如果带有：</p><pre><code>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者: ccr39链接：ccr39.love来源：CCR39のLazyNest</code></pre><p><strong>请先将这段文字删去</strong>，仅保留剩下的文字。</p><p>解压密码已经<strong>在文件名</strong>中标出，但解压密码<strong>不包含文件后缀</strong>，如<code>.rar</code> <code>.zip</code>，等。</p><p><strong>PC</strong> 秒传链接：</p><pre><code>4ed25fa122220cd0189dfe35f991841e#2777077378#PC 密码 acgngame.7z</code></pre><p><strong>KRKR</strong> 秒传链接：</p><pre><code>76ea3b5f9e0f6b9bbd59ad464212106d#945523634#KRKR 密码 acgngame.7z</code></pre><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      《纸上魔法师》资源分享，以及攻略。
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Galgame" scheme="http://ccr39.github.io/tags/Galgame/"/>
    
      <category term="PC" scheme="http://ccr39.github.io/tags/PC/"/>
    
      <category term="KRKR" scheme="http://ccr39.github.io/tags/KRKR/"/>
    
  </entry>
  
  <entry>
    <title>【Galgame】【PC/ONS】悠之空</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/Gal-you/"/>
    <id>http://ccr39.github.io/资源/Gal-you/</id>
    <published>2023-01-08T07:39:53.000Z</published>
    <updated>2024-12-13T05:56:36.150Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h3><p>《悠之空》（ハルカナソラ）是日本游戏社Sphere研发的一款单机游戏，于2009年发行，应用于PC平台。是前作游戏《缘之空》的后续作品。</p><h3 id="二、剧情介绍"><a href="#二、剧情介绍" class="headerlink" title="二、剧情介绍"></a>二、剧情介绍</h3><p>游戏主要讲述了主人公春日野悠与双胞胎妹妹春日野穹（主要路线）的故事。<br>以及天女目瑛、渚一叶、乃木坂初佳、依媛奈绪和中里亮平的故事，同时扩充了前作中没有的仓永梢与伊福部八寻路线（次要线路）。<br>还增加了壁纸，剧场版（人物）的插件，并带有特典。<br>主要还是以穹妹线为主，继续讲述悠与穹的爱情故事，以及穹与悠从山上下来到去北欧（赫尔辛基）旅游之间的故事，并有到北欧后的生活片段。</p><h3 id="三、游戏CG"><a href="#三、游戏CG" class="headerlink" title="三、游戏CG"></a>三、游戏CG</h3><p><img src="https://i0.hdslb.com/bfs/album/f1fd23894848f6513641ee6d6cd1ee55f4f328ec.jpg" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/album/b2a13a97edeb3ab8045f935d3c6a57c31c0b54cb.jpg" alt="img"></p><h3 id="四、资源分享"><a href="#四、资源分享" class="headerlink" title="四、资源分享"></a>四、资源分享</h3><p><font color=red>请先观看：</font><a href="https://ccr39.github.io/%E8%B5%84%E6%BA%90/galgame/">【索引】下载 Galgame 资源须知 </a></p><p>请直接点击<strong>代码框右上角的图标</strong>进行复制，复制后的文本如果带有：</p><pre><code>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者: ccr39链接：ccr39.love来源：CCR39のLazyNest</code></pre><p><strong>请先将这段文字删去</strong>，仅保留剩下的文字。</p><p>解压密码已经<strong>在文件名</strong>中标出，但解压密码<strong>不包含文件后缀</strong>，如<code>.rar</code> <code>.zip</code>，等。</p><p><strong>PC</strong> 秒传链接：</p><pre><code>f5a42414bf9b59c80234ed26cfb64016#1304749401#悠之空PC 解压密码acgmg.rar</code></pre><p><strong>ONS</strong> 秒传链接：</p><pre><code>54305a79febfeb8c983b98aace8bb9b9#598145499#001 【ONS】悠之空 密码：qingju.7z</code></pre><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      悠之空资源分享
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Galgame" scheme="http://ccr39.github.io/tags/Galgame/"/>
    
      <category term="PC" scheme="http://ccr39.github.io/tags/PC/"/>
    
      <category term="ONS" scheme="http://ccr39.github.io/tags/ONS/"/>
    
  </entry>
  
  <entry>
    <title>【Galgame】【PC/ONS】缘之空</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/Gal-sora/"/>
    <id>http://ccr39.github.io/资源/Gal-sora/</id>
    <published>2023-01-08T07:28:41.000Z</published>
    <updated>2024-12-13T05:56:29.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、游戏介绍"><a href="#一、游戏介绍" class="headerlink" title="一、游戏介绍"></a>一、游戏介绍</h3><p>《缘之空》（日语：ヨスガノソラ，英语：Yosuga no Sora）是 Sphere 于2008年12月5日发售的恋爱文字冒险游戏，也是 Sphere 的第一部作品，以“双胞胎兄妹恋”为主题，并因此引发大量争议。亦有漫画、动画、Fandisk、广播剧等衍生作品，其主线讲述了一对双胞胎兄妹摆脱世俗观念的束缚、坚持找寻心中的真爱的故事。</p><h3 id="二、剧情介绍"><a href="#二、剧情介绍" class="headerlink" title="二、剧情介绍"></a>二、剧情介绍</h3><p>春日野悠和他的双胞胎妹妹春日野穹在父母死于车祸之后，来到了远离都市的田园小镇奥木染的祖父家中，在那里开始新的生活。一边和不习惯的家务苦战，一边还要照顾平时足不出户、什么事情都不会做的妹妹穹，悠的生活变得异常艰辛。与此同时悠也受到了曾经一同玩耍的邻家大姐姐依媛奈绪、刚转校便结识了的中里亮平、神社的巫女兼管理人天女目瑛、以及她的朋友渚一叶和乃木坂初佳等人的热情欢迎。同儿时的印象几乎没有变化的村镇和人们，那让人怀念的回忆和温馨的环境，治愈着悠心中的伤痕。就在这样的过程中，慢慢地发生了一些变化。儿时所定下的只属于两个人的秘密的约定，以及所失去的重要东西的下落。还有定下了这个地方的真正理由。作为回忆铭刻在心之时，也已经悄悄开始。就这样悠的新生活展开了。在安稳的日子里，很快悠注意到了对自己来说谁是最重要的存在……面对伤痕累累，一路蹒跚走过的“她”，悠又会如何面对呢？阳光愈发灿烂的初夏的天空下，故事就这样开始了……</p><h3 id="三、游戏CG"><a href="#三、游戏CG" class="headerlink" title="三、游戏CG"></a>三、游戏CG</h3><p><img src="https://i0.hdslb.com/bfs/album/c34537e692ac804c765ed874415fdfa999c87205.jpg" alt="b1ec39cad856762cfbb48eacf91c3b08d3414f4429aa2e37da681de0c7d8477f4a93311cd2cc4aa293bf490f6aea3a06 (690×517) (weiyun.com)"></p><p><img src="https://i0.hdslb.com/bfs/album/1e8632f85e72bed1ead74090fd95d2fb0bd69f60.jpg" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/album/e1ce8184102e6351ea50cde57c1dfc6393379365.jpg" alt="7d889a7e90677f3211c81274bf4d20f7afdd9f0ff788197b9c2970cdc603050b61d4b7f17deeff8cb0174cd7ce36d59f (772×505) (weiyun.com)"></p><h3 id="四、游戏攻略（谨慎观看）"><a href="#四、游戏攻略（谨慎观看）" class="headerlink" title="四、游戏攻略（谨慎观看）"></a>四、游戏攻略（谨慎观看）</h3><p>注：穹线二周目才会开启（通完任意一人的结局后从最初开始）<br>标有◆号的选项为二周目出现的选项，初次游戏时不出现，无视即可。</p><p><strong>穹线<br>敲门（2周目）<br>别看我这样，我也是成长了不少了哦？<br>从今往后也能和和乐乐的当朋友吗<br>捉弄过头的话，是不是不大好啊<br>穹妹 END</strong></p><p><strong>奈绪线<br>今天这先这样吧<br>◆今后也要麻烦你了。<br>从今往后也能和和乐乐的当朋友吗<br>捉弄过头的话，是不是不大好啊<br>奈绪 END</strong></p><p><strong>瑛线<br>◆今天这先这样吧<br>别看我这样，我也是成长了不少了哦？<br>我想了解一下天女目的事情……<br>捉弄过头的话，是不是不大好啊<br>瑛 END</strong></p><p><strong>一叶线<br>◆今天这先这样吧<br>别看我这样，我也是成长了不少了哦？<br>从今往后也能和和乐乐的当朋友吗<br>不过，我觉得这就是有意思的地方<br>一叶 END</strong></p><p><strong>初佳线<br>◆今天这先这样吧<br>别看我这样，我也是成长了不少了哦？<br>从今往后也能和和乐乐的当朋友吗<br>捉弄过头的话，是不是不大好啊<br>初佳 END</strong></p><h3 id="五、资源分享"><a href="#五、资源分享" class="headerlink" title="五、资源分享"></a>五、资源分享</h3><p><font color=red>请先观看：</font><a href="https://ccr39.github.io/%E8%B5%84%E6%BA%90/galgame/">【索引】下载 Galgame 资源须知 </a></p><p>请直接点击<strong>代码框右上角的图标</strong>进行复制，复制后的文本如果带有：</p><pre><code>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者: ccr39链接：ccr39.love来源：CCR39のLazyNest</code></pre><p><strong>请先将这段文字删去</strong>，仅保留剩下的文字。</p><p>解压密码已经<strong>在文件名</strong>中标出，但解压密码<strong>不包含文件后缀</strong>，如<code>.rar</code> <code>.zip</code>，等。</p><p><strong>PC</strong> 秒传链接：</p><pre><code>f9e8bb23a25233fc4e9b699f6ddf8a71#1873592191#缘之空PC 解压密码acgmg.rar</code></pre><p><strong>ONS</strong> 秒传链接：</p><pre><code>d34915fa632ffae0064419242a2729f4#1432325083#004 ［ONS］缘X之X空 密码：qingju.7z</code></pre><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      缘之空资源分享
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Galgame" scheme="http://ccr39.github.io/tags/Galgame/"/>
    
      <category term="PC" scheme="http://ccr39.github.io/tags/PC/"/>
    
      <category term="ONS" scheme="http://ccr39.github.io/tags/ONS/"/>
    
  </entry>
  
  <entry>
    <title>2023新年的第一份二次元美图</title>
    <link href="http://ccr39.github.io/%E8%BD%AC%E8%BD%BD/pic-2023-1/"/>
    <id>http://ccr39.github.io/转载/pic-2023-1/</id>
    <published>2023-01-08T06:34:00.000Z</published>
    <updated>2024-12-13T05:57:27.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i0.hdslb.com/bfs/album/f01999f6f9982c4704932458be60d578c54c9542.png" alt="62423081_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/e7089e81c9c453e0bf9768a51154ff0e474cd201.jpg" alt="62608184_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/91e357811259849c89dedb95f2db5983928ba4e9.png" alt="74129239_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/6dfd81e374abda40665f442469594cdb061f4406.jpg" alt="81332838_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/4de94f6666337ded0d7b6c3df4b4992be31a9c30.png" alt="84932457_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/a223b8eb59743f35c73557eb5853c32edf057f69.jpg" alt="97917035_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/587b1e9775c5fa0d6baf5901fe2ba778db6a6a87.jpg" alt="99460122_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/665f83494218eb6d41515611e842b8a17381b1d2.png" alt="103990581_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/16d769dc705231d7a773320e9ec98d86bfb9896b.jpg" alt="104177374_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/f381dd6ac7cb37babf6ca527847467c9dcee2d50.png" alt="104270210_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/2228ba0ca600137357a7e47dd63c3057a23837d8.png" alt="104272186_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/6215d060ddee82e8706dbc12546b22ede213115e.png" alt="102604294_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/264c71f1b8e07bedae5dba6b526baf9092bec36a.jpg" alt="104289966_p1"></p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      图片来源为 pixiv。
    
    </summary>
    
      <category term="转载" scheme="http://ccr39.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="图集" scheme="http://ccr39.github.io/tags/%E5%9B%BE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>【索引】下载 Galgame 资源须知 + 超详细的 Galgame 各种模拟器及工具使用教程</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/galgame/"/>
    <id>http://ccr39.github.io/资源/galgame/</id>
    <published>2023-01-07T08:06:45.000Z</published>
    <updated>2024-12-13T05:56:45.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、关于资源的下载"><a href="#一、关于资源的下载" class="headerlink" title="一、关于资源的下载"></a>一、关于资源的下载</h2><p>本人会不定期把一些 Galgame 的资源分享到博客上，资源一律采用百度网盘的秒传链接，不使用其他的链接。</p><p>关于秒传链接的提取，可以阅读 <a href="https://ccr39.love/%E8%B5%84%E6%BA%90/panbaidu/">这篇文章</a> 的<strong>第五节</strong>。你也可以阅读整篇文章，了解百度网盘<strong>不限速</strong>下载的方法。</p><h2 id="二、资源的使用"><a href="#二、资源的使用" class="headerlink" title="二、资源的使用"></a>二、资源的使用</h2><p>下载完毕后请解压压缩包，所有的压缩包密码，全部在压缩包名上，请大家留意。</p><p>分享的所有资源仅提供 Windows 与安卓，至于 IOS 的游戏资源以及使用，暂不提供。</p><p>如果你使用的是安卓手机端，建议下载以下工具。</p><table><thead><tr><th align="center">工具名称</th><th align="center">作用描述</th></tr></thead><tbody><tr><td align="center"><a href="https://wwi.lanzouo.com/ipJSKx41g2b">MT管理器</a></td><td align="center">强大的文件管理器，方便你找到文件。</td></tr><tr><td align="center"><a href="https://wwi.lanzoui.com/ib8iesndqvg">ZArchiver</a></td><td align="center">简称ZA，强大的解压工具。支持中文密码，也可以在 Google Play 下载正版。</td></tr><tr><td align="center"><a href="https://wwi.lanzoui.com/iSAydsndsuh">WINRAR</a></td><td align="center">同样强大的解压工具，支持中文密码,同时可以修复.RAR格式的压缩包。</td></tr></tbody></table><p>可能会遇到压缩包为分卷压缩的情况，即同一文件使用多部份压缩，请确保全部的压缩包在同一目录下，并仅对某一压缩包进行解压即可。</p><p>下面我们分别讲解不同资源的用法:</p><h3 id="1、PC-资源"><a href="#1、PC-资源" class="headerlink" title="1、PC 资源"></a>1、PC 资源</h3><h4 id="①在-PC-上的使用"><a href="#①在-PC-上的使用" class="headerlink" title="①在 PC 上的使用"></a>①在 PC 上的使用</h4><p>在电脑上使用 PC 资源的使用一般较为方便，在我们将资源成功解压后，一般直接打开游戏目录中的 .exe 文件，打开即可运行。</p><h4 id="②在安卓端的使用"><a href="#②在安卓端的使用" class="headerlink" title="②在安卓端的使用"></a>②在安卓端的使用</h4><p>我们可以用一些模拟器，在安卓上运行<strong>部分</strong> PC 游戏的资源，并不是所有游戏都能被模拟器运行，所以可以多次尝试。</p><ul><li><p><strong>JoiPlay</strong> 模拟器</p><p><strong>安装</strong>：参考视频<a href="https://www.bilibili.com/video/BV1i44y1P7aP/?spm_id_from=444.64.search-card.all.click&vd_source=0cf100f40d6e892f3c398dd257aaeb68">手把手教你安装joiplay模拟器</a></p><p><strong>使用</strong>：参考视频<a href="https://www.bilibili.com/video/BV1Jp4y1b7AV/?vd_source=0cf100f40d6e892f3c398dd257aaeb68">Joiplay安卓模拟器使用教程</a></p></li><li><p><strong>ExaGear</strong>模拟器</p><p><strong>教程</strong>：参考视频<a href="https://www.bilibili.com/video/BV1AD4y1k7WS/?vd_source=0cf100f40d6e892f3c398dd257aaeb68">ExaGear模拟器的使用方法</a></p></li></ul><h3 id="2、KRKR-资源"><a href="#2、KRKR-资源" class="headerlink" title="2、KRKR 资源"></a>2、KRKR 资源</h3><p>KRKR 资源是为 KRKR2 模拟器使用的资源，KRKR2 是专门面向于安卓的手机 Galgame 模拟器，也是最常用的手机模拟器之一。</p><p>由于最新版的 Tyranor 模拟器增加了对 KRKR 的支持，因此，我们还可以用 Tyranor 模拟器运行 KRKR 资源。</p><h4 id="使用-KRKR2-模拟器"><a href="#使用-KRKR2-模拟器" class="headerlink" title="使用 KRKR2 模拟器"></a>使用 KRKR2 模拟器</h4><h5 id="①安装"><a href="#①安装" class="headerlink" title="①安装"></a>①安装</h5><p>下载链接:<a href="https://wwi.lanzoui.com/ie6Ljsndlkf"> KRKR2 模拟器</a></p><h5 id="②使用"><a href="#②使用" class="headerlink" title="②使用"></a>②使用</h5><p>打开 KRKR2 模拟器，找到资源解压后的目录，找到目录中的 .xp3 文件，点击即可运行。</p><h4 id="使用-Tyranor-模拟器"><a href="#使用-Tyranor-模拟器" class="headerlink" title="使用 Tyranor 模拟器"></a>使用 Tyranor 模拟器</h4><h5 id="①安装-1"><a href="#①安装-1" class="headerlink" title="①安装"></a>①安装</h5><p>下载链接：<a href="https://wwu.lanzouy.com/ijunD07almsj">Tyranor模拟器</a></p><h5 id="②使用-1"><a href="#②使用-1" class="headerlink" title="②使用"></a>②使用</h5><p>打开 Tyranor 模拟器，在 “添加” 页面点击最右上角的图标选择路径。</p><p>点击右侧图标进行预览。</p><p><img src="https://i0.hdslb.com/bfs/album/5fcddeed3c1481446ecba05d2026e3d84f6e5201.jpg" alt="img"></p><p>在<strong>进入</strong>游戏的<strong>根目录</strong>时点击右下角对勾，即可添加游戏。</p><p>添加完成后，直接点击运行即可运行游戏。</p><h3 id="3、ONS-资源"><a href="#3、ONS-资源" class="headerlink" title="3、ONS 资源"></a>3、ONS 资源</h3><p>ONS 资源可以在 ONS 模拟器使用，ONS 的一大优势是，它可以在大部分平台中运行，你可以在<a href="https://onscripter.osdn.jp/onscripter.html">官方网站</a>中了解。</p><p>这里我们讲的是 Windows 和安卓的使用。</p><h4 id="①在-PC-上运行-ONS-游戏"><a href="#①在-PC-上运行-ONS-游戏" class="headerlink" title="①在 PC 上运行 ONS 游戏"></a>①在 PC 上运行 ONS 游戏</h4><p>下载 <a href="https://wwi.lanzoui.com/iYBxdukwt2d">PC ONS 启动器</a>，并解压。</p><p>打开游戏目录，并直接将刚才的解压的所有文件放入<strong>游戏目录</strong>。</p><p><img src="https://i0.hdslb.com/bfs/album/719bd8c53230308a1d71ff0cbda1397e48d5527e.png" alt="image-20230107185518037"></p><p>在游戏目录中点击 ONScripter-Jh.exe 即可运行。</p><h4 id="②在手机运行-ONS-游戏"><a href="#②在手机运行-ONS-游戏" class="headerlink" title="②在手机运行 ONS 游戏"></a>②在手机运行 ONS 游戏</h4><h5 id="使用-ONS-JH-模拟器"><a href="#使用-ONS-JH-模拟器" class="headerlink" title="使用 ONS-JH 模拟器"></a>使用 ONS-JH 模拟器</h5><p>在此下载 <a href="https://wwi.lanzoui.com/imwAbsndlch">ONS-JH 模拟器</a>，如果有能力，建议去 Google Play 下载正版。</p><p>打开 ONS-JH 模拟器，并在模拟器中直接打开游戏所在目录，即可使用。</p><h5 id="使用-Mine-模拟器"><a href="#使用-Mine-模拟器" class="headerlink" title="使用 Mine 模拟器"></a>使用 Mine 模拟器</h5><p>Mine 基于 ONS 模拟器制作的，功能跟 ONS 模拟器大致相同。</p><p>同时，Mine 还可能支持其他游戏，具体可自行探索。</p><p>下载 <a href="https://pan.baidu.com/s/1PrJb3F8DGYJINuLaei-n9A?pwd=tmbx">Mine 模拟器</a></p><p>使用教程参考视频：<a href="https://www.bilibili.com/video/BV1W3411s73o/?spm_id_from=..search-card.all.click&vd_source=0cf100f40d6e892f3c398dd257aaeb68">【MINE模拟器】使用教程</a></p><h3 id="4、安卓直装资源"><a href="#4、安卓直装资源" class="headerlink" title="4、安卓直装资源"></a>4、安卓直装资源</h3><p>即以安卓 app 安卓包形式存在的资源，文件后缀为<code>.apk</code>，此类资源在安卓手机直接下载后直接安装就可以使用。</p><h3 id="5、Tyranor-资源"><a href="#5、Tyranor-资源" class="headerlink" title="5、Tyranor  资源"></a>5、Tyranor  资源</h3><p>Tyranor 可以运行 Artemis 引擎制作的游戏，比如富婆妹。</p><p>使用方法和下载在上面的 KRKR 资源中已经说过，这里就不说了。</p><h3 id="6、Pymo-资源"><a href="#6、Pymo-资源" class="headerlink" title="6、Pymo 资源"></a>6、Pymo 资源</h3><p>pymo 是一个手机上的 Galgame 引擎，其运行依赖于 pymo 模拟器。</p><p>下载： <a href="https://wwi.lanzoui.com/is2QLu2a6yh">Pymo 模拟器</a></p><p>在手机上打开 pymo，选择游戏所在的文件夹就会开始游戏。</p><h3 id="7、maldives-资源"><a href="#7、maldives-资源" class="headerlink" title="7、maldives 资源"></a>7、maldives 资源</h3><p>Maldives 模拟器可以在手机上运行近几年RPG的游戏（特点是有www文件夹）</p><p>下载：<a href="https://wwi.lanzouy.com/igJSXz7u4ab">MaldiVes模拟器</a></p><p>使用方法与之前几个大体相似。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      使用本站 Galgame 资源分享前必读。
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Galgame" scheme="http://ccr39.github.io/tags/Galgame/"/>
    
      <category term="索引" scheme="http://ccr39.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Clash 的安装与详细的使用</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/clash/"/>
    <id>http://ccr39.github.io/技术/clash/</id>
    <published>2023-01-06T08:47:35.000Z</published>
    <updated>2024-12-13T05:56:08.360Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于时效性，本文章可能随时进行更新，文章内容可能会有误，我会在评论区修正，请谅解。</strong></p><p>科学上网可以说是网上冲浪的必备技能了，相信大家也接触过不少科学上网的工具。</p><p>这里我们介绍一个最常用的科学上网工具之一: <strong>Clash</strong></p><p>与 Clash 同样常用且强大的工具是V2ray，两者均可在各大系统操作系统中有相应客户端，以下我们主要介绍 Clash 在Windows上和在 Android上的使用，如果想为 IOS 配置 Clash 代理可以参考下文第四节的内容，其他系统的使用方法可以自行搜索。如果你想要了解更高级的使用方法，可以阅读<a href="https://docs.cfw.lbyczf.com/">官方文档</a>以了解更多。</p><h2 id="一、购买节点并获取订阅链接"><a href="#一、购买节点并获取订阅链接" class="headerlink" title="一、购买节点并获取订阅链接"></a>一、购买节点并获取订阅链接</h2><p>首先我们要去机场购买节点，所谓机场就是提供代理服务的网站。我们可以在机场购买订阅并获取订阅链接来使用网络代理服务。</p><p>机场提供的服务并不一定是稳定，高速，安全的。所以需要进行一定斟酌后再选用机场。而且由于再大陆内，提供代理网络服务并不合法，所以机场也有可能随时跑路，所以在购买节点时不建议长期订阅。</p><p>机场的价格往往与速度，稳定性挂钩，但是机场的价格普遍并不高。</p><p>博主使用的机场在<a href="https://www.efcloud.cc/#/register?code=AtpsDqhe">这里</a>，最便宜的价格的话是一个月一元100G，最高速度可以顶满带宽，完全足够个人使用。注册时记得输入邀请码:AtpsDqhe。</p><p>同时，机场一般也会提供使用方法和客户端资源，你可以参考机场上的方法来配置Clash。</p><h2 id="二、Clash的基本使用"><a href="#二、Clash的基本使用" class="headerlink" title="二、Clash的基本使用"></a>二、Clash的基本使用</h2><h3 id="1、Clash-for-Windows"><a href="#1、Clash-for-Windows" class="headerlink" title="1、Clash for Windows"></a>1、Clash for Windows</h3><h4 id="①下载客户端"><a href="#①下载客户端" class="headerlink" title="①下载客户端"></a>①下载客户端</h4><p><a href="https://ghproxy.com/https://github.com/ender-zhao/Clash-for-Windows_Chinese/releases/download/CFW-V0.20.12_CN/Clash.for.Windows.Setup.0.20.12.exe">国内镜像下载</a>、<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/latest">官方Github发布页</a>（若国内无法访问官方发布页，请使用国内镜像）</p><p>云盘中的不一定为最新版，最新版可在官方发布页下载。</p><h5 id="使用汉化包"><a href="#使用汉化包" class="headerlink" title="使用汉化包"></a>使用汉化包</h5><p>前往：<a href="https://github.com/BoyceLig/Clash_Chinese_Patch/releases/">官方发布页</a>无法访问时请<a href="https://wwqs.lanzoub.com/ieSoM0ket0nc">在此</a>进行下载</p><p>如下图，将<code>app.asar</code>直接放入 resources 文件夹中，并进行替换。</p><p><img src="https://i0.hdslb.com/bfs/album/03f09b6aa5a83cfbcc0b0240c077672b2d66035b.png" alt="image-20230106213603592"></p><p>再次启动汉化成功。</p><h4 id="②导入配置文件"><a href="#②导入配置文件" class="headerlink" title="②导入配置文件"></a>②导入配置文件</h4><p>首次启动 Clash for Windows 后会出现下图所示界面代表启动成功：</p><p><img src="https://i0.hdslb.com/bfs/album/a479c8ff1869e2ece3f01267283cffcf05cc7a5b.png" alt="img"></p><p>导入配置文件有如下两个途径：</p><ul><li>URL 导入</li><li>本地文件拖拽导入</li></ul><p>你可以在机场中复制订阅地址来获得URL。</p><h5 id="URL-导入"><a href="#URL-导入" class="headerlink" title="URL 导入"></a>URL 导入</h5><p>点击界面左侧菜单 Profiles（即：配置），在顶部输入框填入 URL 并点击 Download 下载即可，下载完成后点击对应的配置文件即可载入</p><p><img src="https://i0.hdslb.com/bfs/album/e1c20872284b3c15273fd725b70f5233daba9064.png" alt="img"></p><h5 id="本地文件拖拽导入"><a href="#本地文件拖拽导入" class="headerlink" title="本地文件拖拽导入"></a>本地文件拖拽导入</h5><p>如果无法通过 URL 下载配置文件，则可以尝试在浏览器中下载配置文件后通过拖拽方式导入</p><p><img src="https://i0.hdslb.com/bfs/album/1a1e8198015b06ad69ea1cfe8f7d23f4088efdd9.gif" alt="img"></p><h4 id="③打开系统代理"><a href="#③打开系统代理" class="headerlink" title="③打开系统代理"></a>③打开系统代理</h4><p>返回 General 常规中，打开<code>System Proxy</code>系统代理即可，如果你希望开机自启，也可以勾选 <code>Start with Windows</code>开机自启。</p><ul><li><p>System Proxy：设置系统代理</p></li><li><p>Start with Windows: 设置开机自启</p></li></ul><p><img src="https://i0.hdslb.com/bfs/album/b295422b3f1535cc21f8542b7e8143b28ba03ad2.png" alt="img"></p><h3 id="2、Clash-for-Android"><a href="#2、Clash-for-Android" class="headerlink" title="2、Clash  for  Android"></a>2、Clash  for  Android</h3><h4 id="①下载客户端-1"><a href="#①下载客户端-1" class="headerlink" title="①下载客户端"></a>①下载客户端</h4><p><a href="https://wwqs.lanzoub.com/iXfyS0keslsh">云盘</a> 提取码：1og4，<a href="https://github.com/Kr328/ClashForAndroid/releases">Github 官方</a>（若国内无法访问官方发布页，请使用国内镜像），<a href="https://play.google.com/store/apps/details?id=com.github.kr328.clash&hl=zh-cn">Google Play</a>（没有代理无法访问）</p><p>云盘中的不一定为最新版，最新版可在官方发布页下载。</p><h4 id="②添加订阅"><a href="#②添加订阅" class="headerlink" title="②添加订阅"></a>②添加订阅</h4><p>面板是有一键订阅的,直接点击就好,手动如下步骤</p><p>打开 Clash for Android ，依次进入 配置 &gt; 新配置 &gt; URL 。 在 URL 一栏中粘贴 Clash 配置订阅链接；自动更新 (分钟) 推荐填写 1440 ，即每 24 小时自动从链接中更新配置文件。</p><p><img src="https://i0.hdslb.com/bfs/album/f32ece7af42a79da60c80e35472912ede242879a.png" alt="img"></p><p>完成后点击右上角的保存按钮，Clash for Android 将下载配置文件，请点击选中添加的配置文件。</p><p><img src="https://i0.hdslb.com/bfs/album/54e14d9f71a273a1a610a430c912c79fbf6cdc5f.png" alt="img"></p><h4 id="③开启代理"><a href="#③开启代理" class="headerlink" title="③开启代理"></a>③开启代理</h4><p>返回软件首页。点击开关，即可进行代理。会提示是否同意创建VPN，请点击<code>允许</code>。</p><p><img src="https://i0.hdslb.com/bfs/album/b4f8e259084248fdcf0aedfc194b8ffc35a8ffa8.png" alt="img"></p><p>点开 “代理”，可以策略组进行选择。</p><h2 id="三、其他基本功能"><a href="#三、其他基本功能" class="headerlink" title="三、其他基本功能"></a>三、其他基本功能</h2><h3 id="1、代理模式"><a href="#1、代理模式" class="headerlink" title="1、代理模式"></a>1、代理模式</h3><h4 id="①代理模式的区别"><a href="#①代理模式的区别" class="headerlink" title="①代理模式的区别"></a>①代理模式的区别</h4><p>Clash 提供了 全局、规则、直连、脚本 四种代理模式。</p><ul><li>全局：设备上所有支持代理协议的浏览器、程序的 IP 均使用代理，换句通俗的话说，就是整个设备都通过代理来访问外部网络。</li><li>规则：使用 Clash 的规则文件进行上网流量分流，比如让国内IP、域名的流量直连，让国外的IP、域名通过代理连接。</li><li>直连：意思是直接连接，不使用代理上网。</li><li>脚本：利用用户自己写的脚本文件进行流量分流，需要配置脚本文件使用</li></ul><h4 id="②设置代理模式"><a href="#②设置代理模式" class="headerlink" title="②设置代理模式"></a>②设置代理模式</h4><p>在 Windows 端的 代理 的上方，从左到右依次为 全局 、规则 、直连 、脚本</p><p><img src="https://i0.hdslb.com/bfs/album/ba38e1be85c71fec0a99081f3e7df64dd409b77b.png" alt="image-20230107102620940"></p><p>在安卓端的 代理 中，点击右上角三个点，在弹出的框中的 模式 里可以设置代理模式，但仅在此次有效，下次启动会重新使用默认设置</p><p><img src="https://i0.hdslb.com/bfs/album/0176c49ba46cfe468b3a281ac09403a43f32e9fd.jpg" alt="img"></p><p>你也可以在设置中更改默认模式：点击 设置 &gt;&gt; 覆写 &gt;&gt; 模式</p><p><img src="https://i0.hdslb.com/bfs/album/c40cb3299cf2639ed90dfe4b8455f1997be41dcb.jpg" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/album/7a45fc9f98440a03eebcd826200a6a88660e2ced.jpg" alt="img"></p><h3 id="2、设置终端代理"><a href="#2、设置终端代理" class="headerlink" title="2、设置终端代理"></a>2、设置终端代理</h3><p>在 Windows 端，可以直接为控制终端设置代理，来解决在终端中安装超时的问题。</p><p><img src="https://i0.hdslb.com/bfs/album/eca6383f81b25866bc40979b19419f37e50403c9.png" alt="image-20230107104212697"></p><h3 id="3、打开-Clash-的-Web-控制台"><a href="#3、打开-Clash-的-Web-控制台" class="headerlink" title="3、打开  Clash 的 Web 控制台"></a>3、打开  Clash 的 Web 控制台</h3><p>点击 Clash 核心后面的那行字。</p><p><img src="https://i0.hdslb.com/bfs/album/36a69d76f8452f98c0039faa4825aad2b1b9dadd.png" alt="image-20230107104457419"></p><p>此时我们就可以进入控制台</p><p><img src="https://i0.hdslb.com/bfs/album/353412355718e3bad1378e85005ca212d77d1248.png" alt="image-20230107104512368"></p><h2 id="四、使用-Clash-为局域网中的其他设备配置代理"><a href="#四、使用-Clash-为局域网中的其他设备配置代理" class="headerlink" title="四、使用 Clash 为局域网中的其他设备配置代理"></a>四、使用 Clash 为局域网中的其他设备配置代理</h2><p>使用 Clash 的 “允许局域网连接” 功能可以为 Clash 为局域网内的其他设备进行代理。</p><p>利用这个方法，我们可以解决在 IOS 端，配置 Clash 困难，复杂的问题。</p><h3 id="1、配置-Windows-端"><a href="#1、配置-Windows-端" class="headerlink" title="1、配置 Windows 端"></a>1、配置 Windows 端</h3><p>①打开 ”允许局域网连接” <img src="https://i0.hdslb.com/bfs/album/745c90ec132c89241b2c2ec9dda411442dc44bf8.png" alt="image-20230107105041262"></p><p>②点击 “允许局域网连接” 后方的图标，查看网络接口</p><p><img src="https://i0.hdslb.com/bfs/album/81ebc01c1ee1cb6ee8c6a63bc0a61e234c53008d.png" alt="image-20230107105331837"></p><p>③点击 “端口” 后方的数字，设置端口，端口号的范围应在 0 到 1023 ，你也可以使用默认的端口号不去设置。</p><h3 id="2、配置其他客户端"><a href="#2、配置其他客户端" class="headerlink" title="2、配置其他客户端"></a>2、配置其他客户端</h3><p>这里拿 IOS 举例，安卓或其他客户端大体相似，具体可自行查询 。</p><p>首先保证 PC 与手机在同一局域网下。</p><p>①打开手机设置：</p><p><img src="https://i0.hdslb.com/bfs/album/249eeca817f7838b1a18b51e270c22fbdebf5bd7.webp" alt="1000"></p><p>②打开 WiFi 设置；</p><p><img src="https://i0.hdslb.com/bfs/album/ebe1e53567643db11c1ccbbd43527b46110ac440.webp" alt="1000"></p><p>③向下滑动，找到HTTP设置——配置代理；</p><p><img src="https://i0.hdslb.com/bfs/album/0d2f48dfb13984a6ffa285d3c36ea860ba421404.webp" alt="1000"></p><p>④将配置代理的关闭勾选为手动；</p><p><img src="https://inews.gtimg.com/newsapp_bt/0/15227546881/1000" alt="img"></p><p>⑤将刚才查看的网络接口地址，和端口号分别填入服务器和端口中。</p><p>保存之后即可生效，其代理模式和 PC 端保持一致。</p><p>如果你不在想用代理，重新把配置代理关闭即可。</p><h2 id="五、完毕"><a href="#五、完毕" class="headerlink" title="五、完毕"></a>五、完毕</h2><p>到此，一些关于 Clash 的基本使用技巧已经简单概述，如果您还需要更多进阶技巧，可从此<a href="https://docs.cfw.lbyczf.com/">文档</a>中获取。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      Clash 的安装，以及机场的订阅。Clash 配置局域网代理，Clash 汉化包。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vim的安装以及基础使用</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/vim/"/>
    <id>http://ccr39.github.io/技术/vim/</id>
    <published>2023-01-05T13:24:00.000Z</published>
    <updated>2024-12-13T05:57:50.932Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 是从 Vi 发展出来的一个文本编辑器，也是所有的 Unix Like 内置的文本编辑器。其拥有强大的对代码的处理功能，因此成为了许多大佬写代码的首选。</p><p>这里要说明, Vim 不是 IDE 他可以在任何的平台中使用，也没有对语言的限制。</p><p>可以说，学好对 Vim ，可以让你的手几乎不会离开键盘的主操作区，对我们有着极大的帮助。</p><h3 id="一、Vim-在-Windows-上的安装"><a href="#一、Vim-在-Windows-上的安装" class="headerlink" title="一、Vim 在 Windows 上的安装"></a>一、Vim 在 Windows 上的安装</h3><h4 id="1、直接安装-Vim-本体"><a href="#1、直接安装-Vim-本体" class="headerlink" title="1、直接安装 Vim 本体"></a>1、直接安装 Vim 本体</h4><p>在<a href="https://www.vim.org/download.php#pc">官网</a>中直接下载 Gvim 的安装包，根据提示进行安装。</p><p>安装完成之后，即可以从目录中启动 Vim ，或者，你可以在控制台中输入 Vim 进行使用。（当然要保证已经为 Vim 配置了环境变量）</p><p><img src="https://i0.hdslb.com/bfs/album/91c814cb3b478fe5bc5aad4d1afbbf0e18445085.png"></p><h4 id="2、在-VS-Code-中使用-Vim"><a href="#2、在-VS-Code-中使用-Vim" class="headerlink" title="2、在 VS Code  中使用 Vim"></a>2、在 VS Code  中使用 Vim</h4><p>直接在 VS Code 的拓展中搜索 Vim 即可让 VS Code 的文本编译方式转为和 Vim 相同。</p><p><img src="https://i0.hdslb.com/bfs/album/b54142a63ab086bbf799a9a545be5fe8c5158e65.png"></p><h3 id="二、Vim-的学习和使用"><a href="#二、Vim-的学习和使用" class="headerlink" title="二、Vim 的学习和使用"></a>二、Vim 的学习和使用</h3><p>如果你是安装的 Gvim 本体的话，你可以直接在控制台输入 <code>vimtutor</code>使用 Vim 自带的学习文档进行学习。</p><p>下面将在这里介绍 Vim 的基本使用。</p><p>如下图，Vim 为我们编辑文本提供了三种方式：命令模式、输入模式、底线命令模式。</p><p><img src="https://i0.hdslb.com/bfs/album/bfe47f2595be5e1031a5b43b673916ad90f27678.png"></p><p>当我们打开 Vim 默认的模式即为命令模式，在命令模式下，我们不能完成文本的输入等操作，但是我们可以通过键盘上的按键来操作并编辑文本。</p><p>当我们在命令模式下输入 : 时，会进入底线命令模式，这个时候，光标会在左下角出现，我们可以输入相应的指令并按回车执行指令。</p><p>在命令模式下，当我们输入 i a o 三个键时，即可进入输入模式，在输入模式下，我们可以正常的输入文字，如果想要切换回命令模式，需要按 esc 键。</p><p>下面是 vi&#x2F;vim 的键盘图</p><p><img src="https://i0.hdslb.com/bfs/album/0cfcae47854e492ed03c1ff8bc727efb85a690cc.gif"></p><p>Vim 的指令十分强大，需要一段时间的学习和适应，在熟悉按键之后，即可达到非常强大的效果。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      Vim 是从 Vi 发展出来的一个文本编辑器，也是所有的 Unix Like 内置的文本编辑器。其拥有强大的对代码的处理功能，因此成为了许多大佬写代码的首选。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://ccr39.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>BOCCHI THE ROCK!</title>
    <link href="http://ccr39.github.io/%E8%BD%AC%E8%BD%BD/bochinorock/"/>
    <id>http://ccr39.github.io/转载/bochinorock/</id>
    <published>2022-12-20T14:23:43.000Z</published>
    <updated>2024-12-13T05:56:01.848Z</updated>
    
    <content type="html"><![CDATA[<p>图片均来自于pixiv</p><h4 id="BOCHI"><a href="#BOCHI" class="headerlink" title="BOCHI"></a>BOCHI</h4><p><img src="https://i0.hdslb.com/bfs/album/0364f555e25e82ee8149d26094c91c2b7b6329e7.jpg" alt="103623763_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/46cae7409bbecfd0faa7ce477101f18f1d1a3154.jpg" alt="71286435_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/e7f51a64243142100e46728cd7f7ed51a3cf566b.png" alt="87245758_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/586427e8dee5903f2e04d197826304a5c61041e6.jpg" alt="102525167_p1"></p><p><img src="https://i0.hdslb.com/bfs/album/e116837c3e504d8bb520f241ff820a3b68f3152d.jpg" alt="102545983_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/91aed94cbc692229a6a2117f051e319a50e32475.jpg" alt="102545983_p1"></p><p><img src="https://i0.hdslb.com/bfs/album/93e18f650db95e42b915b0f9be05f45b77ab2816.jpg" alt="102633947_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/41752dbf82ac132e052fb44f86f05d1838abbb73.png" alt="102747940_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/674861b5a17e9df38c841fcd91db5696745fc735.jpg" alt="102992503_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/c6419f433e3c583a2edc0586a376a96ac83ae9cf.jpg" alt="103207286_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/3cb4472d03bbbae9c82e0da77dd5bb14ebf87f04.jpg" alt="4QsM2a8qEAG7k3I"></p><p><img src="https://i0.hdslb.com/bfs/album/e5d2651a760604cedd2d01118efd260c556775f3.jpg" alt="103584845_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/b467bd88e1a9f5b04144d9232efb24f7283bff5f.jpg" alt="103699340_p0"></p><h4 id="虹夏"><a href="#虹夏" class="headerlink" title="虹夏"></a>虹夏</h4><p><img src="https://i0.hdslb.com/bfs/album/432fe7a64a45b32fc52bdd85da26f92977ffb6e2.png" alt="102428118_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/2f00116c46cfb8877112a148bbf27a29613184d9.png" alt="102611735_p0"></p><p><img src="https://s2.loli.net/2022/12/20/dKh3CFEpjWce4i8.jpg" alt="102631448_p0"></p><p><img src="https://s2.loli.net/2022/12/20/rqTVe6wmoN23DAn.jpg" alt="102743429_p0"></p><p><img src="https://s2.loli.net/2022/12/20/FHVPq3LeoX9nzrm.jpg" alt="103110459_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/36cafccf695b04175dfa9bd510052fc1dfb75a1a.png" alt="103478209_p0"></p><p><img src="https://s2.loli.net/2022/12/20/JGw1ARMOpg4QifY.jpg" alt="103622290_p0"></p><p><img src="https://s2.loli.net/2022/12/20/EQ2Jz5UFiBDw9mj.jpg" alt="103707133_p0"></p><h4 id="喜多"><a href="#喜多" class="headerlink" title="喜多"></a>喜多</h4><p><img src="https://i0.hdslb.com/bfs/album/4b95679209240768218ade345c333dbbbc13b0a0.png" alt="102659264_p0"></p><p><img src="https://s2.loli.net/2022/12/20/KTGEDXCVdbsaAoe.png" alt="102799828_p0"></p><p><img src="https://s2.loli.net/2022/12/20/BgUbWIfFJYLCrxS.jpg" alt="102937742_p0"></p><p><img src="https://s2.loli.net/2022/12/20/jFxWqEbZJveO657.jpg" alt="103607509_p0"></p><p><img src="https://s2.loli.net/2022/12/20/uIaJ3OVXjWdgfCs.jpg" alt="103701381_p0"></p><h4 id="凉"><a href="#凉" class="headerlink" title="凉"></a>凉</h4><p><img src="https://s2.loli.net/2022/12/20/IG3BjzAwJqRgLUy.jpg" alt="102650565_p0"></p><p><img src="https://s2.loli.net/2022/12/20/sXWEm7taI1MdyvQ.jpg" alt="103125154_p0"></p><p><img src="https://s2.loli.net/2022/12/20/ZU6iwA7BaGztrJD.png" alt="103560795_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/bc6403397a07d63d11166b1bdb4c1dd425605ce6.png" alt="image-20221220224805644"></p><p><img src="https://s2.loli.net/2022/12/20/JokQACHdvVF1yTR.jpg" alt="103585595_p0"></p><p><img src="https://i0.hdslb.com/bfs/album/c34eca4e4be203340e11e5b4b19e64f8bf9a4aa9.png" alt="103629349_p0"></p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      pixiv孤独摇滚美图精选
    
    </summary>
    
      <category term="转载" scheme="http://ccr39.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="图集" scheme="http://ccr39.github.io/tags/%E5%9B%BE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>从零开始速通百度云网盘</title>
    <link href="http://ccr39.github.io/%E8%B5%84%E6%BA%90/panbaidu/"/>
    <id>http://ccr39.github.io/资源/panbaidu/</id>
    <published>2022-12-18T06:20:37.000Z</published>
    <updated>2024-12-13T05:57:16.216Z</updated>
    
    <content type="html"><![CDATA[<p><strong>由于时效性，本文章可能随时进行更新，文章内容可能会有误，我会在评论区修正，请谅解。</strong></p><p>相信大家在网上冲浪时时常会下载一些资源、软件，如果你需要下载别人分享的资源时，就需要用到网盘。</p><p>百度云网盘由于早期在国内占据了一定规模的市场，拥有大量的资源与链接，直至目前，百度云网盘仍是被使用最多的网盘。但是百度的不当人做法，让百度云网盘的限速到达了堪称恐怖的境界，但另一方面，坐拥大量资源的百度云网盘让我们不得不通过它进行资源的传输。所以不少人选择了向百度屈服，充了百度的SVIP，但就算是SVIP仍然逃不过限速的命运。</p><p>还有这样一种情况，就是我们经常会看到一些资源分享链接，结果还没有来得及下载，链接就失效了。</p><p>直链下载和秒传链接就能帮助我们解决上述两个问题。</p><p>今天，由我为大家带来，从零开始速通百度云网盘，把带宽顶满，生成永久有效的秒链，从此告别限速与分享无效。</p><p>全文提供安卓和 Windows 两种方案，<strong>前面先讲的直链，秒链在最后面</strong>。</p><p>如果大家之前接触过安卓端使用ES文件管理器加ADM的方法，本人实测该方法已失效，所以请使用本文提供的方法。</p><h2 id="一、准备工作-科学上网（可自行跳过）"><a href="#一、准备工作-科学上网（可自行跳过）" class="headerlink" title="一、准备工作:科学上网（可自行跳过）"></a>一、准备工作:科学上网（可自行跳过）</h2><p>科学上网可以说是网上冲浪的必备技能了，相信大家也接触过不少科学上网的工具。</p><p>这里我们介绍一个最常用的科学上网工具之一: <strong>Clash</strong></p><p>与 Clash 同样常用且强大的工具是V2ray，两者均可在各大系统操作系统中有相应客户端，以下我们主要介绍 Clash 在Windows上和在 Android上的使用，其他系统的使用方法可以自行搜索。如果你想要了解更高级的使用方法，可以阅读<a href="https://docs.cfw.lbyczf.com/">官方文档</a>以了解更多。</p><h3 id="1、购买节点并获取订阅链接"><a href="#1、购买节点并获取订阅链接" class="headerlink" title="1、购买节点并获取订阅链接"></a>1、购买节点并获取订阅链接</h3><p>首先我们要去机场购买节点，所谓机场就是提供代理服务的网站。我们可以在机场购买订阅并获取订阅链接来使用网络代理服务。</p><p>机场提供的服务并不一定是稳定，高速，安全的。所以需要进行一定斟酌后再选用机场。而且由于再大陆内，提供代理网络服务并不合法，所以机场也有可能随时跑路，所以在购买节点时不建议长期订阅。</p><p>机场的价格往往与速度，稳定性挂钩，但是机场的价格普遍并不高。</p><p>博主使用的机场在<a href="https://www.efcloud.cc/#/register?code=AtpsDqhe">这里</a>，最便宜的价格的话是一个月一元100G，最高速度可以顶满带宽，完全足够个人使用。注册时记得输入邀请码:AtpsDqhe。</p><p>同时，机场一般也会提供使用方法和客户端资源，你可以参考机场上的方法来配置Clash。</p><h3 id="2、Clash-for-Windows"><a href="#2、Clash-for-Windows" class="headerlink" title="2、Clash for Windows"></a>2、Clash for Windows</h3><h4 id="①下载客户端"><a href="#①下载客户端" class="headerlink" title="①下载客户端"></a>①下载客户端</h4><p><a href="https://ghproxy.com/https://github.com/ender-zhao/Clash-for-Windows_Chinese/releases/download/CFW-V0.20.12_CN/Clash.for.Windows.Setup.0.20.12.exe">国内镜像下载</a>、<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/latest">官方Github发布页</a>（若国内无法访问官方发布页，请使用国内镜像）</p><p>云盘中的不一定为最新版，最新版可在官方发布页下载。</p><p>首次启动 Clash for Windows 后会出现下图所示界面代表启动成功：</p><p><img src="https://i0.hdslb.com/bfs/album/a479c8ff1869e2ece3f01267283cffcf05cc7a5b.png" alt="img"></p><h4 id="②导入配置文件"><a href="#②导入配置文件" class="headerlink" title="②导入配置文件"></a>②导入配置文件</h4><p>导入配置文件有如下两个途径：</p><ul><li>URL 导入</li><li>本地文件拖拽导入</li></ul><p>你可以在机场中复制订阅地址来获得URL。</p><h5 id="URL-导入"><a href="#URL-导入" class="headerlink" title="URL 导入"></a>URL 导入</h5><p>点击界面左侧菜单 Profiles，在顶部输入框填入 URL 并点击 Download 即可，下载完成后点击对应的配置文件即可载入</p><p><img src="https://i0.hdslb.com/bfs/album/e1c20872284b3c15273fd725b70f5233daba9064.png" alt="img"></p><h5 id="本地文件拖拽导入"><a href="#本地文件拖拽导入" class="headerlink" title="本地文件拖拽导入"></a>本地文件拖拽导入</h5><p>如果无法通过 URL 下载配置文件，则可以尝试在浏览器中下载配置文件后通过拖拽方式导入</p><p><img src="https://i0.hdslb.com/bfs/album/1a1e8198015b06ad69ea1cfe8f7d23f4088efdd9.gif" alt="img"></p><h4 id="③打开系统代理"><a href="#③打开系统代理" class="headerlink" title="③打开系统代理"></a>③打开系统代理</h4><p>返回 General 中，打开<code>System Proxy</code>即可，如果你希望开机自启，也可以勾选 <code>Start with Windows</code>。</p><ul><li><p>System Proxy：设置系统代理</p></li><li><p>Start with Windows: 设置开机自启</p></li></ul><p><img src="https://i0.hdslb.com/bfs/album/b295422b3f1535cc21f8542b7e8143b28ba03ad2.png" alt="img"></p><h3 id="3、Clash-for-Android"><a href="#3、Clash-for-Android" class="headerlink" title="3、Clash  for  Android"></a>3、Clash  for  Android</h3><h4 id="①下载客户端-1"><a href="#①下载客户端-1" class="headerlink" title="①下载客户端"></a>①下载客户端</h4><p><a href="https://wwqs.lanzoub.com/iXfyS0keslsh">云盘</a> 提取码：1og4，<a href="https://github.com/Kr328/ClashForAndroid/releases">Github 官方</a>（若国内无法访问官方发布页，请使用国内镜像），<a href="https://play.google.com/store/apps/details?id=com.github.kr328.clash&hl=zh-cn">Google Play</a>（没有代理无法访问）</p><p>云盘中的不一定为最新版，最新版可在官方发布页下载。</p><h4 id="②添加订阅"><a href="#②添加订阅" class="headerlink" title="②添加订阅"></a>②添加订阅</h4><p>面板是有一键订阅的,直接点击就好,手动如下步骤</p><p>打开 Clash for Android ，依次进入 配置 &gt; 新配置 &gt; URL 。 在 URL 一栏中粘贴 Clash 配置订阅链接；自动更新 (分钟) 推荐填写 1440 ，即每 24 小时自动从链接中更新配置文件。</p><p><img src="https://i0.hdslb.com/bfs/album/f32ece7af42a79da60c80e35472912ede242879a.png" alt="img"></p><p>完成后点击右上角的保存按钮，Clash for Android 将下载配置文件，请点击选中添加的配置文件。</p><p><img src="https://i0.hdslb.com/bfs/album/54e14d9f71a273a1a610a430c912c79fbf6cdc5f.png" alt="img"></p><h4 id="③开启代理"><a href="#③开启代理" class="headerlink" title="③开启代理"></a>③开启代理</h4><p>返回软件首页。点击开关，即可进行代理。会提示是否同意创建VPN，请点击<code>允许</code>。</p><p><img src="https://i0.hdslb.com/bfs/album/b4f8e259084248fdcf0aedfc194b8ffc35a8ffa8.png" alt="img"></p><p>点开 “代理”，可以策略组进行选择。</p><h2 id="二、tampermonkey"><a href="#二、tampermonkey" class="headerlink" title="二、tampermonkey"></a>二、tampermonkey</h2><p>tampermonkey（油猴）是一个强大的浏览器插件，他为脚本在浏览器内运行提供了一个环境。</p><p>通过油猴我们可以使用脚本来做到许多神奇的操作，接下来我来带大家使用tampermonkey。</p><h3 id="1、浏览器的使用"><a href="#1、浏览器的使用" class="headerlink" title="1、浏览器的使用"></a>1、浏览器的使用</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>说到浏览器插件，首先就要说浏览器了，首推浏览器现在是Edge，适配绝大部分插件。</p><p>如果你有谷歌账号还熟练科学上网，推荐Chrome。</p><blockquote><p>实际上，常见的几乎所有国产浏览器，甚至手机的APP，以及Edge使用的是都是开源的chromemiu内核。</p><p>但其实Edge最初是自己制作内核，但是微软的工程师最后屈服于谷歌了。</p><p>所以Edge可以适配谷歌的所有插件，甚至可以一建导入，而且Edge在国内没被墙以及还有许多其他功能（Win10以上自带），所以在国内掀起了一波推崇热潮。</p><p>本人因为不想再下chrome用了自带的Edge，但实际体验极差，经常会卡顿，无响应。</p><p>所以我的推荐是，如果你会用Chrome还是不要用Edge了。</p></blockquote><p>其次的推荐Firefox、Opera。</p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>在安卓平台，首推kiwi浏览器，可以适用谷歌的所有插件，你可以再<a href="https://play.google.com/store/apps/details?id=com.kiwibrowser.browser">Google play</a>上直接搜索下载，如果你不会使用Google play可以<a href="https://pan.baidu.com/s/18YJ_ls_SKNKicBRYkwy9BA?pwd=mqpv">在此（百度网盘）</a>或<a href="https://alist.quickso.cn/kiwi">在此(推荐)</a>本地安装包。</p><p>你还可以在<a href="https://kiwibrowsercn.github.io/">Kiwi浏览器中文网</a>，获取更多的下载方式和详细的使用方法。</p><h3 id="2、安装tampermonkey"><a href="#2、安装tampermonkey" class="headerlink" title="2、安装tampermonkey"></a>2、安装tampermonkey</h3><h4 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h4><h5 id="①插件商店安装"><a href="#①插件商店安装" class="headerlink" title="①插件商店安装"></a>①插件商店安装</h5><p>以Edge为例，找到右上角三个点，点击&gt;拓展&gt;<a href="https://microsoftedge.microsoft.com/addons?hl=zh-CN">获取 Microsoft Edge 扩展</a>&gt;搜索tampermonkey点击获取</p><p>这里注意，不建议安装tampermonkey Beta因为Beta版本的某些功能并不稳定。</p><p>如果你使用的是Chrome浏览器，那么想要用谷歌的扩展商店需要科学上网，如果无法科学上网可以使用本地安装的方法。</p><h5 id="②本地安装"><a href="#②本地安装" class="headerlink" title="②本地安装"></a>②本地安装</h5><p>你还可以选择在<a href="https://pan.baidu.com/s/1erjqmYm4JmoIGv_0ZpBgZg?pwd=2k83">这里（百度云）</a>或<a href="https://softxm.lanzoui.com/ittn00472wja">这里（蓝奏云）</a>下载本地文件，完毕后打开浏览器，这里还是以Edge为例。</p><p>右上角三个点，点击&gt;扩展&gt;打开“开发者模式”&gt;打开之后把下载好的本地文件直接拖入即可安装。</p><p>如果显示出错无法安装右击文件，把文件后缀 .crx 改为 .zip 把文件解压，然后再次来到扩展页面，保证开发者模式打开，点击”加载解压缩的扩展”，进入到刚才解压好的文件夹的根目录，点击选择文件夹即可。</p><p><img src="https://i0.hdslb.com/bfs/album/86cd8c7a72e1d3178034eddfd0ba31c25c887e09.png" alt="屏幕截图 2022-12-17 225518"></p><p>这时可能会发生显示出错的情况，如:</p><p><img src="https://i0.hdslb.com/bfs/album/f99d0af2da0435206f9a02b4146dd45544402b91.png" alt="屏幕截图 2022-12-17 225729"></p><p>这种情况不用在意，可以正常使用。</p><h4 id="Android-1"><a href="#Android-1" class="headerlink" title="Android"></a>Android</h4><h5 id="①插件商店安装-1"><a href="#①插件商店安装-1" class="headerlink" title="①插件商店安装"></a>①插件商店安装</h5><p>Kiwi浏览器的商店依赖的时谷歌插件商店，因此需要科学上网。</p><p>打开Kiwi浏览器，先新建标签页，点击右上角三个点 &gt; 扩展程序 &gt; +(from store) &gt; 搜索 tampermonkey &gt; 添加到Chrome</p><p>同样，不建议安装tampermonkey Beta，因为Beta版本的某些功能并不稳定。</p><h5 id="②本地安装-1"><a href="#②本地安装-1" class="headerlink" title="②本地安装"></a>②本地安装</h5><p>在<a href="https://pan.baidu.com/s/1erjqmYm4JmoIGv_0ZpBgZg?pwd=2k83">这里（百度云）</a>或<a href="https://softxm.lanzoui.com/ittn00472wja">这里（蓝奏云）</a>下载本地文件，完毕后要注意文件被下载到的位置，不同手机浏览器的文件位置可能不一样，所以可以自行搜索并查找。</p><p>打开Kiwi浏览器，先新建标签页，点击右上角三个点 &gt; 扩展程序 &gt; +(from .zip&#x2F;.crx&#x2F;.user.js) </p><p>这时候在出现的文件管理器中找到刚才下载的文件，点击添加即可。</p><h3 id="3、安装脚本"><a href="#3、安装脚本" class="headerlink" title="3、安装脚本"></a>3、安装脚本</h3><p>确保安装完成tampermonkey后再次确保tampermonkey打开。</p><p>在浏览器内点击<a href="https://greasyfork.org/zh-CN/scripts/418182-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%AE%80%E6%98%93%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E7%9B%B4%E9%93%BE%E4%B8%8B%E8%BD%BD%E5%A4%8D%E6%B4%BB%E7%89%88">这里</a>，点击安装此脚本以安装脚本。</p><p>安装成功后进入插件的管理面板，在电脑端浏览器，点击右上角拼图样式的图标&gt;点击tampermonkey&gt;管理面板。</p><p>在手机端中点击三个点，下滑到最后，找到tampermonkey，点击后再点击管理面板。</p><p>进入管理面板可以看到:</p><p><img src="https://i0.hdslb.com/bfs/album/1fe2be9b7f4939d488364a8573122a663676e468.png" alt="image-20221217232808739"></p><p>确保脚本打开，至此插件脚本安装成功。</p><h2 id="三、下载器的安装及配置"><a href="#三、下载器的安装及配置" class="headerlink" title="三、下载器的安装及配置"></a>三、下载器的安装及配置</h2><h4 id="Windows端-IDM下载器"><a href="#Windows端-IDM下载器" class="headerlink" title="Windows端:IDM下载器"></a>Windows端:IDM下载器</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>在<a href="https://softxm.lanzoui.com/iTfYl045962h">这里</a>下载IDM破解版,然后解压。</p><h5 id="配置UA"><a href="#配置UA" class="headerlink" title="配置UA"></a>配置UA</h5><p>我提供的IDM是绿色版本，解压后，执行“!)绿化.bat”，就可以正常使用了。<br><strong>IDM配置</strong>：修改UA为 <strong>netdisk;PC</strong></p><p><img src="https://i0.hdslb.com/bfs/album/d3619b6ff9687223fc81406260442e7a139ae19a.png" alt="img"></p><h4 id="Android端-ADM下载器"><a href="#Android端-ADM下载器" class="headerlink" title="Android端:ADM下载器"></a>Android端:ADM下载器</h4><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装:"></a>安装:</h5><p><a href="https://wwqs.lanzoub.com/ihvtf0ixw1ni">蓝奏云</a>,密码:2z6b</p><p><a href="https://pan.baidu.com/s/1ezna3ReSLd9qWGpZqIubMw?pwd=jv67">百度云</a></p><p>[Google Play](<a href="https://play.google.com/store/apps/details?id=com.dv.adm&gl=US">Advanced Download Manager - Google Play 上的应用</a>)</p><h5 id="配置UA-1"><a href="#配置UA-1" class="headerlink" title="配置UA"></a>配置UA</h5><p>进入ADM，点击设置&gt;下载中，滑倒最下方找到浏览器标识。选择最下方的自定义，然后再最下方的自定义设置中输入<code>netdisk;PC</code>。保存</p><p><img src="https://i0.hdslb.com/bfs/album/74ecb42d4387eb78e3b56e616045eb01fbfcb67b.jpg" alt="8A9641096D25DB0F40DE328FFE9FF6EC"></p><p><img src="https://i0.hdslb.com/bfs/album/3c9a60b28265211e1d9844fb07e278b9f2a5cb42.jpg" alt="E7611CD2D796277A305C6949FECA542E"></p><p><img src="https://i0.hdslb.com/bfs/album/63f555db25c5defe03e518110453137d2d9b4931.jpg" alt="B235B8DA73179154E838F2D66A9E2F23"></p><p><img src="https://i0.hdslb.com/bfs/album/796f0fadbb639fd2b843a34a79b48c4813a93454.jpg" alt="50CE2BE8F7CDB3A76C656B0560A54189"></p><p><img src="https://i0.hdslb.com/bfs/album/26ca4741b9110722ded38036d534e8fac55feaea.jpg" alt="57326DEE9C789ECB7BD34E55014E0CBC"></p><h2 id="四、获取直链并下载"><a href="#四、获取直链并下载" class="headerlink" title="四、获取直链并下载"></a>四、获取直链并下载</h2><p>将百度网盘中你想下载的文件转存如自己的网盘中。</p><p>如果是安卓端，需要在Kiwi浏览器右上角三个点勾选桌面版网站来访问电脑版网站。</p><p>同时，因为在手机端打开网页会自动跳转，请保证在勾选桌面版网站之后访问<a href="https://pan.baidu.com/disk/main#/index?category=all">百度网盘网页端</a>。</p><p>打开浏览器，进入<a href="https://pan.baidu.com/disk/main#/index?category=all">百度网盘网页端</a>，找到刚才转存的文件。</p><p>勾选，并点击简易下载助手。</p><p><img src="https://s2.loli.net/2022/12/18/mLbkXHx7ZMcdFSa.png" alt="屏幕截图 2022-12-18 111730"></p><p>点击获取直链地址，如果需要验证码可以根据提示，关注公众号，获取验证码，填写完毕后再次点击获取直链地址。</p><p>完成后点击复制直链地址，这里也要注意，关注下方的公告，我们已经把UA改为目前可用的UA，但不排除更换的可能性，如果需要更换UA，请根据下方公告填写。</p><h4 id="Windows-2"><a href="#Windows-2" class="headerlink" title="Windows"></a>Windows</h4><p>接下来打开IDM，点击新建任务。</p><p><img src="https://s2.loli.net/2022/12/18/HT8u6B2jSlPts4L.png" alt="image-20221218112353177"></p><p>将刚才的直链地址复制进去点击确定，开始下载。</p><p><img src="https://s2.loli.net/2022/12/18/AQO6qn9eUfEwjS4.png" alt="image-20221218112504667"></p><p>可以看到，我们的带宽已经跑满。</p><h4 id="Android-2"><a href="#Android-2" class="headerlink" title="Android"></a>Android</h4><p>进入ADM,点击下方加号把刚才的直链复制进去。</p><p><img src="https://s2.loli.net/2022/12/18/9gVrIhxwckPSQmC.jpg" alt="8D225EEB02CB9DC1F3D4DBE7599ADAE1"></p><p>展开高级选项，在下方的浏览器标识中选择”自定义”，接下来点击开始进行下载。</p><p><img src="https://s2.loli.net/2022/12/18/2tlAfjSGQ5oxag3.jpg" alt="9BABD44F94B8B7F2DED33B1C715B0D19"></p><p>网速也是跑满了带宽:</p><p><img src="https://s2.loli.net/2022/12/18/KeTWHYZ3aB6u2lU.jpg" alt="FD32E0FB3C9DD9BB4E813B2CEBB1F248"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="无权限下载"><a href="#无权限下载" class="headerlink" title="无权限下载"></a>无权限下载</h4><p>这是因为UA设置错误导致的，请查看是否有新的UA，然后再按上面的方法重新配置UA。</p><p>在ADM中，一定要保证在下载时的浏览器表示中使用自定义。</p><h4 id="下载过慢-x2F-网速不正常"><a href="#下载过慢-x2F-网速不正常" class="headerlink" title="下载过慢&#x2F;网速不正常"></a>下载过慢&#x2F;网速不正常</h4><p>这可能与你的线程设置有关系，ADM和IDM的默认线程数为8线程，而脚本要求的线程数是4线程。</p><p>常规来说，在带宽顶满之前，线程数越多下载速度越快，但是过多的线程数可能会引起系统异常，从而停止对你的文件传输。</p><p>实际使用来说，使用8线程一般不会造成问题，但也存在例外。</p><p>因此，如果下载速度异常，请先尝试将最大线程数调到4线程，如果无效，可以尝试配置更多的线程观察是否对下载速度有一定帮助。</p><p>下面介绍修改最大线程数的方法。</p><p>IDM：<img src="https://s2.loli.net/2022/12/18/2q1kYVKDsjv4gpy.jpg" alt="img"></p><p> ADM:在添加下载任务&gt;高级选项中</p><p><img src="https://s2.loli.net/2022/12/18/K4t2Daxvk3GzquB.jpg" alt="387C05B4D974FD0B523CF5D7016A941B"></p><h2 id="五、秒传链接的使用"><a href="#五、秒传链接的使用" class="headerlink" title="五、秒传链接的使用"></a>五、秒传链接的使用</h2><p>秒传链接实现了分享网盘资源永久分享。</p><p>接下来介绍秒传链接的使用方法。</p><h3 id="Windows-3"><a href="#Windows-3" class="headerlink" title="Windows"></a>Windows</h3><p>在安装完Tampermonkey的浏览器中点击<a href="https://greasyfork.org/zh-CN/scripts/424574-%E7%A7%92%E4%BC%A0%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%96">这个</a>链接。</p><p>点击安装后点击安装此脚本，进行安装。</p><p>完成后进入到网页版百度网盘，选择需要传输的文件，点击生成秒传。</p><p><img src="https://s2.loli.net/2022/12/18/xObJSnwPtieTrq8.png" alt="image-20221218130007933"></p><p>接下来点击复制秒传代码即可生成。</p><p><img src="https://s2.loli.net/2022/12/18/Cx3t6lmc78rQTJ4.png" alt="image-20221218130055870"></p><p>想要导入秒传文件，则点击秒传，并将秒传链接复制在其中。</p><h3 id="Android-3"><a href="#Android-3" class="headerlink" title="Android"></a>Android</h3><p>在安卓端，你可以参考上面的方法在Kiwi浏览器中打开<a href="https://greasyfork.org/zh-CN/scripts/424574-%E7%A7%92%E4%BC%A0%E9%93%BE%E6%8E%A5%E6%8F%90%E5%8F%96">这个</a>，下载脚本。</p><p>并打开桌面版网站，进入百度云网盘，和上面Windows端使用同样的方法进行秒传。</p><p>这里我们介绍另一种方法，依靠的是手机的客户端导入秒传文件（仅支持导入，想要生成还是用上面的办法）。</p><p>首先下载狐悠（<a href="https://pan.baidu.com/s/1v54fJZFTDp5Iem-ceiOjIA?pwd=bf7v">百度网盘</a>、<a href="https://wwqs.lanzoub.com/iNpkz0iy47fe">蓝奏云 提取码：2mu9</a>)</p><p>进入APP，然后登陆百度网盘，直接将秒传链接复制进去即可导入秒传文件。</p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，你已经学会了如何以正确姿势使用百度网盘了，请记住，白嫖是有代价的，不爱折腾不可能得到良好的体验。</p><p><strong>只有能折腾，才能获得更好的体验，所以不要犯懒，经过上述方法，你一定能完美使用百度网盘</strong></p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      教给大家如何科学的使用百度云网盘，从零开始速通百度云网盘，把带宽顶满，生成永久有效的秒链，从此告别限速与分享无效。
    
    </summary>
    
      <category term="资源" scheme="http://ccr39.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="软件" scheme="http://ccr39.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>编程环境的搭建与scoop的使用</title>
    <link href="http://ccr39.github.io/%E6%8A%80%E6%9C%AF/scoop/"/>
    <id>http://ccr39.github.io/技术/scoop/</id>
    <published>2022-12-16T14:46:00.000Z</published>
    <updated>2024-12-13T05:57:42.398Z</updated>
    
    <content type="html"><![CDATA[<p>学习计算机编程语言，想必第一件事情就是搭建所需的环境，但往往环境的搭建是非常折磨人的。</p><p>你是否曾自己一人，抱着满腔热血，试图学习某门语言，但却因为 IDE 或编译器无法运行而在各个网页间来回穿梭？</p><p>你是否在想要使用别人的项目时，却面对这琳琅满目的报错中独自发愁。</p><p>鲁迅曾经说过“我刚开始学编程，最痛苦的一件事就是搭建环境。”那么今天我就为大家来避避踩过的坑。</p><h3 id="一、何为环境？"><a href="#一、何为环境？" class="headerlink" title="一、何为环境？"></a>一、何为环境？</h3><p>  编程环境的方面包括很多，简单来说，编程环境指的是能供让代码或程序正常运行的环境。</p><p>那么需要哪些条件呢?</p><p>拿C++举例，首先你要有一个IDE，用来编写代码。其次你要有一个编译器，来编译代码。</p><p>那么这一套用来编译，并运行的条件就是C++的运行环境。(最简单的i</p><h3 id="二、系统环境变量"><a href="#二、系统环境变量" class="headerlink" title="二、系统环境变量"></a>二、系统环境变量</h3><p>环境变量的使用是避坑的第一个环节。</p><p>记得学OI那会，第一次使用VS Code，闹腾半天愣是不知道如何添加环境变量，现在回想下来，其实原因就在于没有理解环境变量究竟是什么。</p><p>当你在控制台输入一些程序( 比如Windows自带的cmd时 )，你可能会看到这句话:</p><blockquote><p>Microsoft Windows [版本 10.0.22621.819]<br>(c) Microsoft Corporation。保留所有权利。</p></blockquote><p>这句话中包含了cmd的版本信息。</p><p>但是你是否想过，我们分明没有输入cmd的路径，但是系统是如何找到cmd的所在位置呢?</p><p>如果在最初搭建环境踩过坑的人，可能会联想到另外一种情况，就比如说，你在控制台输入<code>$ python index.py</code>时可能会报出出的错误:</p><blockquote><p>‘python’ 不是内部或外部命令，也不是可运行的程序<br>或批处理文件。</p></blockquote><p>想必聪明的读者一定能想得到，在这里系统并没有找到python的位置。</p><p>可能是两种情况:</p><ol><li>电脑中不存在python。</li><li>电脑中存在python但是不能被系统像找到cmd那样找到。</li></ol><p>那么现在就可以回答上面那个问题:<strong>系统是如何找到cmd的所在位置呢?</strong></p><p>答案就是<strong>环境变量</strong>。</p><p>在你的系统中，环境变量是用来储存一些程序的位置的东西，有了它系统就能知道程序的路径在哪里，所以想要解决上面的问题，我们就要知道如何去通过修改环境变量来使系统能够找到程序。</p><p>在Windows操作系统下，右击桌面上的此电脑，点击属性&gt;&gt;高级系统设置&gt;&gt;高级&gt;&gt;环境变量。即可修改环境变量。</p><p>而我们一般把值储存在<strong>Path变量</strong>中，值的格式就是你的程序的<strong>目录</strong>的路径，多个路径之间用逗号相隔。(在Win10以及以上版本中，你只点击编辑环境变量&gt;&gt;新建，就能够添加新的地址，而在其他版本中，则需要在整个变量最后添加逗号,再输入新的路径)</p><p>在这里，Windows还提供了两类环境变量，一个是用户变量，储存的变量是储存在用户中的，另外一个是系统变量，储存在系统中。如果不太了解什么意思，其实无论存在系统还是用户中都可以正常使用。</p><p>当我们用安装包安装的时候，环境变量一般会自动添加到系统中，但也不乏一些个例，从而可能会引起上述报错。还有人因为挪动了根目录的位置从而报错，原因也不难猜了，只需要把原来的环境变量修改为根目录就行了。</p><p>现在我们就可以理解上面的报错了，我们只需要把python的目录复制，添加到环境变量的Path变量中，就可以解决问题。还有、其他问题，比如报错说存在多个程序，那么就可能是由于电脑中的多个同名程序都被识别找到，但是系统不知道打开哪一个，这时候你可以用<code>$ where 程序名</code>来获取程序地址，再去环境变量中找到多余的某个路径，删去就可以。</p><p>简单来说，了解环境变量的本质之后，就能很大程度上手动解决许多问题。</p><p>再举一个解决实际问题的例子:</p><ul><li>假如说我们再使用指令<code>$ pip install XXX</code>时报错<code>pip 不是内部或外部命令，也不是可运行的程序或批处理文件。</code>我们就可以进行推测，首先我们知道pip时python自带的安装依赖包的程序，那么有可能是这个程序的目录没有在环境变量中，这时，我们可以查询pip在python目录的哪个地方，再把pip的路径复制，放到环境变量中即可。如果你发现自己的python没有自带pip，我们就可以用python的命令（或其他方法）安装pip，再把路径加入环境变量，即可解决</li></ul><h3 id="三、Scoop的使用"><a href="#三、Scoop的使用" class="headerlink" title="三、Scoop的使用"></a>三、Scoop的使用</h3><p>在 Windows 下，搭建开发环境一直是一个复杂且困难的问题。由于没有一个统一的标准，导致各种开发环境的安装方式差异巨大，需要付出很多不必要的时间成本。而 Scoop 可以帮助你统一安装并管理常见的开发软件，省去了手动下载安装，配置环境变量等繁琐步骤。</p><p>例如安装 python 和 nodejs 只需要执行：</p><pre><code class="powershell">scoop install pythonscoop install nodejs</code></pre><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><p>scoop的安装依靠PoweShell，如果你使用的是 Windows 7 系统，那么PowerShell的版本可能过于陈旧。你可以手动安装新版的PowerShell。</p><p>安装命令:在PowerShell中输入</p><pre><code class="powershell">Set-ExecutionPolicy RemoteSigned -scope CurrentUserirm get.scoop.sh -outfile &#39;install.ps1&#39;.\install.ps1 -ScoopDir &#39;C:\Scoop&#39;</code></pre><h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><p>如：</p><pre><code class="powershell">scoop install python</code></pre><p>即可直接下载，并搭建python的环境。</p><p>详情可见<a href="https://github.com/ScoopInstaller/Scoop/wiki/Quick-Start">官方文档</a>。</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      来解决环境搭建困难的避坑指南。
    
    </summary>
    
      <category term="技术" scheme="http://ccr39.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编程" scheme="http://ccr39.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基础动态规划</title>
    <link href="http://ccr39.github.io/%E8%BD%AC%E8%BD%BD/baseDP/"/>
    <id>http://ccr39.github.io/转载/baseDP/</id>
    <published>2022-12-16T08:59:00.000Z</published>
    <updated>2024-12-13T05:55:53.849Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/blog/ccr39/post-bi-ji-dong-tai-gui-hua-di-yin-ru">原文链接</a></p><h3 id="一、基本概念与定义"><a href="#一、基本概念与定义" class="headerlink" title="一、基本概念与定义"></a>一、基本概念与定义</h3><h4 id="1、动态规划的概念"><a href="#1、动态规划的概念" class="headerlink" title="1、动态规划的概念"></a>1、动态规划的概念</h4><p>对于某些问题，我们可以将其分成若干个互相联系的阶段，并在每个阶段做出决策，从而达到最优解。</p><p>这种通过状态来影响决策，在经由决策引起状态转移的动态过程被称作动态规划（简称DP）</p><p>动态规划（DP）不是某种具体算法，而是一种思想。 </p><p>核心在于：把大问题转化为小问题，利用小问题的解，推断出大问题的解。</p><h4 id="2、状态"><a href="#2、状态" class="headerlink" title="2、状态"></a>2、状态</h4><p>当我们把大问题化成小问题时，只有大问题和小问题拥有相同的形式，才能考虑拆分子问题。</p><p>如果满足这个要求，那么我们遇到的每个子问题，都可以通过某种简洁的形式来 表达。</p><p>我们把可能遇到的每种“局面”称为状态。</p><p>设计完状态之后，只要能利用小状态的解求出大状态的解，就可以动手把题目做 出来！</p><h4 id="3、转移"><a href="#3、转移" class="headerlink" title="3、转移"></a>3、转移</h4><p>当我们设计好状态，我们需要用小状态推出大状态。</p><p>从一个状态的解，得知另一个状态的解，我们称之为“状态转移”。这个转移式子 称为“状态转移方程”。</p><h4 id="4、Dp的基本原则"><a href="#4、Dp的基本原则" class="headerlink" title="4、Dp的基本原则"></a>4、Dp的基本原则</h4><p>（1）最优子结构：大问题的最优解，一定是从小问题的最优解推出来的。</p><p>（2）无后效性：无后效性 现在的决策，只与过去的结果有关，而与过去的决策无关。</p><h4 id="5、DP与记忆化搜索"><a href="#5、DP与记忆化搜索" class="headerlink" title="5、DP与记忆化搜索"></a>5、DP与记忆化搜索</h4><h5 id="1-记忆化搜索"><a href="#1-记忆化搜索" class="headerlink" title="(1)记忆化搜索"></a>(1)记忆化搜索</h5><p>在经$dfs$搜索过程中，会产生许许多多的子序列，对于每个序列，可能会产生重复的元素。</p><p>例如：</p><pre><code>求99！，100！，101！</code></pre><p>一般思路，分别从1开始乘</p><p>但显然，对于这道题我们只需要算出99！，就不需要再从头计算了，因为100！即是99！ * 100，而101 !  即是 100 ！ * 101 ！</p><p>所以说，我们只需要在阶乘的过程中将 99 ! 的得数存到数组a[99]中，等到下次再调到用时，就可以直接访问a[99]，从而省去不必要的时间。</p><p>一般情况下，可以将O($2^n$)的时间复杂度优化为O($n^2$)的复杂度。</p><h5 id="2-DP"><a href="#2-DP" class="headerlink" title="(2)DP"></a>(2)DP</h5><p>对于同样的问题，我们并不考虑如何直接去求 99 !  ,而去考虑如何可以将 99 ！ 分成若干个子问题。</p><p>显然 99 ！ &#x3D;  98 ！ * 99；</p><p>而 98 ! &#x3D; 97! * 98;</p><p>以此类推，我们可以等到： 1 ！ &#x3D;   1</p><p>可以看出，对于所有的阶乘问题，我们都可以从 2的阶乘开始计算，最后一步步到达想要的结果，这就是DP。</p><p>同时，对于这道题，状态转移方程为：a[N] &#x3D; a[N - 1] * N;且a[0]&#x3D;1</p><h4 id="6、DP与递推"><a href="#6、DP与递推" class="headerlink" title="6、DP与递推"></a>6、DP与递推</h4><p>从上面我们的探究可以看出，对于同一个问题，DP的做法是，从最初结点开始遍历，在过程中，我们不考虑之前的值是否存在，也不考虑当决策是否对之后产生影响，只是根据状态转移方程，一步步选择，从而得到结果。</p><p>我们可发现，DP其实运用了递推的思想。</p><p>我们可以把状态转移方程看成递推公式，把初始值看做递推边界。</p><p>对于上题，我们同样可以写成递推公式</p><p>$F_n&#x3D;F_{n-1}*n$；$F_0&#x3D;1$</p><p>同时，我们可以把记忆化搜索看成递归的思想</p><p>在搜索过程中沿着某一个答案前进，在过程中调用之前所储存的答案。</p><p><strong>所以，记忆化搜索和递推也常被当做DP的一种实现方式。</strong></p><h3 id="二、DP程序的设计"><a href="#二、DP程序的设计" class="headerlink" title="二、DP程序的设计"></a>二、DP程序的设计</h3><h4 id="1、转移方式"><a href="#1、转移方式" class="headerlink" title="1、转移方式"></a>1、转移方式</h4><h5 id="（1）backward-型转移：我从哪里来"><a href="#（1）backward-型转移：我从哪里来" class="headerlink" title="（1）backward 型转移：我从哪里来?"></a>（1）backward 型转移：我从哪里来?</h5><p>这是一种常见的思路：对于一个没有求出解的状态，利用能走到它的状态，来得出它的解。</p><p>同时它也是记忆化搜索的方式</p><h5 id="（2）forward-型转移-考虑我到哪里去"><a href="#（2）forward-型转移-考虑我到哪里去" class="headerlink" title="（2）forward 型转移:考虑我到哪里去"></a>（2）forward 型转移:考虑我到哪里去</h5><p>对于一个已经求好了解的状态，拿去更新它能走 到的状态。</p><h4 id="2、DP三连"><a href="#2、DP三连" class="headerlink" title="2、DP三连"></a>2、DP三连</h4><ul><li><p>我是谁? (设计状态)</p></li><li><p>我从哪里来 (backward 型转移)</p></li><li><p>我到那里去 (forward 型转移)</p></li></ul><p>(两种转移方式中，只需要选择一个来设计转移即可。)</p><link    rel="stylesheet"    href="https://unpkg.com/@waline/client@v2/dist/waline.css"  /><div id="waline"></div>  <script type="module">    import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';    init({      el: '#waline',      serverURL: 'https://waline-ccr39.netlify.app/.netlify/functions/comment',       reaction: [        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_heart_eyes.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_joy.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_dog_consider.png',        'https://unpkg.com/@waline/emojis@1.1.0/weibo/weibo_sob.png',      ],      emoji: [        '//unpkg.com/@waline/emojis@1.1.0/bilibili',        '//unpkg.com/@waline/emojis@1.1.0/weibo',        '//unpkg.com/@waline/emojis@1.1.0/qq',      ]    });  </script>]]></content>
    
    <summary type="html">
    
      基础的动态规划
    
    </summary>
    
      <category term="转载" scheme="http://ccr39.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="算法" scheme="http://ccr39.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
